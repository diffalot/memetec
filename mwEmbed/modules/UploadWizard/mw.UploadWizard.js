mw.addMessages( {
	"mwe-upwiz-step-file": "1. Upload your files",
	"mwe-upwiz-step-deeds": "2. Add licenses",
	"mwe-upwiz-step-details": "3. Add descriptions",
	"mwe-upwiz-step-thanks": "4. Use your files",
	"mwe-upwiz-intro": "Welcome to Wikimedia Commons, a repository of images, sounds, and movies that anyone can freely download and use. Add to humanity's knowledge by uploading files that could be used for an educational purpose.",
	
	"mwe-upwiz-add-file-n": "Add another file",
	"mwe-upwiz-add-file-0": "Click here to add a file for upload",
	"mwe-upwiz-browse": "Browse...",
	"mwe-upwiz-transported": "OK",
	"mwe-upwiz-click-here": "Click here to select a file",
	"mwe-upwiz-uploading": "uploading...",
	"mwe-upwiz-editing": "editing...",
	"mwe-upwiz-remove-upload": "Remove this file from the list of files to upload",
	"mwe-upwiz-remove-description": "Remove this description",
	"mwe-upwiz-upload": "Upload",
	"mwe-upwiz-upload-count": "$1 of $2 files uploaded",
	"mwe-upwiz-progressbar-uploading": "uploading",
	"mwe-upwiz-remaining": "$1 remaining",
	"mwe-upwiz-deeds-intro": "Thank you! Now we need to set a license for these files, so everyone can legally view or modify them. First, we'll have to know where you got them.",
	"mwe-upwiz-details-intro": "Now we need some basic information about the files.",
	"mwe-upwiz-source-ownwork": "This file is my own work.",
	"mwe-upwiz-source-ownwork-plural": "These files are my own work.",
	"mwe-upwiz-source-ownwork-assert": "I, $1, the copyright holder of this work, hereby grant anyone the right to use this work for any purpose, as long as they credit me and share derivative work under the same terms.",
	"mwe-upwiz-source-ownwork-assert-plural": "I, $1, the copyright holder of these works, hereby grant anyone the right to use these works for any purpose, as long as they credit me and share derivative work under the same terms.",
	"mwe-upwiz-source-ownwork-assert-custom": "I, $1, the copyright holder of this work, hereby publish this work under the following license(s):",
	"mwe-upwiz-source-ownwork-assert-custom-plural": "I, $1, the copyright holder of these works, hereby publish these works under the following license(s):",
	"mwe-upwiz-source-ownwork-assert-note": "This means you release your work under a double Creative Commons Attribution ShareAlike and GFDL license.",
	"mwe-upwiz-source-permission": "Their author gave you explicit permission to upload them",
	"mwe-upwiz-source-thirdparty": "This file is not my own work.",
	"mwe-upwiz-source-thirdparty-plural": "These files are not my own work.",
	"mwe-upwiz-source-thirdparty-intro" : "Please enter the address where you found each file.",
	"mwe-upwiz-source-thirdparty-custom-plural-intro" : "If all files have the same source, author, and copyright status, you may enter them only once for all of them.",
	"mwe-upwiz-source-thirdparty-license" : "The copyright holder of this work published them under the following license(s):",
	"mwe-upwiz-source-thirdparty-license-plural" : "The copyright holder of these works published them under the following license(s):",
	"mwe-upwiz-source-thirdparty-accept": "OK",
	"mwe-upwiz-source-custom": "Did you know? You can <a href=\"$1\">customize</a> the default options you see here.",
	"mwe-upwiz-more-options": "more options...",
	"mwe-upwiz-fewer-options": "fewer options...",
	"mwe-upwiz-desc": "Description in",
	"mwe-upwiz-desc-add-n": "add a description in another language",
	"mwe-upwiz-desc-add-0": "add a description",
	"mwe-upwiz-title": "Title",
	"mwe-upwiz-categories-intro": "Help people find your works by adding categories",
	"mwe-upwiz-categories-another": "Add other categories",
	"mwe-upwiz-previously-uploaded": "This file was previously uploaded to $1 and is already available <a href=\"$2\">here</a>.",
	"mwe-upwiz-about-this-work": "About this work",
	"mwe-upwiz-media-type": "Media type",
	"mwe-upwiz-date-created": "Date created",
	"mwe-upwiz-location": "Location",
	"mwe-upwiz-copyright-info": "Copyright information",
	"mwe-upwiz-author": "Author(s)",
	"mwe-upwiz-license": "License",
	"mwe-upwiz-about-format": "About the file",
	"mwe-upwiz-autoconverted": "This file was automatically converted to the $1 format",
	"mwe-upwiz-filename-tag": "File name:",
	"mwe-upwiz-other": "Other information",
	"mwe-upwiz-other-prefill": "Free wikitext field",
	"mwe-upwiz-showall": "show all",
	"mwe-upwiz-source": "Source",
	"mwe-upwiz-macro-edit-intro": "Choose a license first above, then you can add some descriptions and other information to your uploads.",
	"mwe-upwiz-macro-edit": "Update descriptions",
	"mwe-upwiz-thanks-intro": "Thanks for uploading your works! You can now use your files on a Wikipedia article or link to them from elsewhere on the web.",
	"mwe-upwiz-thanks-link": "This file is now available at <b><tt>$1</tt></b>.",
	"mwe-upwiz-thanks-wikitext": "<b>To use it in a Wikipedia article</b>, copy this text into an article: ",
	"mwe-upwiz-thanks-url": "<b>To link to it in HTML</b>, copy this HTML code: ",

	"mwe-upwiz-upload-error-bad-filename-extension": "This wiki does not accept filenames with the extension \"$1\".",
	"mwe-upwiz-upload-error-duplicate": "This file was previously uploaded to this wiki.",
	"mwe-upwiz-upload-error-stashed-anyway": "Post anyway?",
	"mwe-upwiz-ok": "OK",
	"mwe-upwiz-cancel": "Cancel",
	"mwe-upwiz-change": "(change)",

	"mwe-fileexists" : "A file with this name exists already. Please check <b><tt>$1<\/tt><\/b> if you are not sure if you want to replace it.",
	"mwe-thumbnail-more" : "Enlarge",
	"mwe-upwiz-overwrite" : "Replace the file",

	"mwe-copyright-macro": "As above",
	"mwe-copyright-custom": "Custom",

	"mwe-upwiz-next": "Next",
	"mwe-upwiz-home": "Go to Wiki home page",
	"mwe-upwiz-upload-another": "Upload more files",

	"mwe-prevent-close": "Your files are still uploading. Are you sure you want to navigate away from this page?",

	"mwe-upwiz-files-complete": "Your files finished uploading!",
	"mwe-upwiz-deeds-later": "Set deeds and licenses for each file individually on the next page"
} );


/**
 * 
 */
mw.UploadWizardDeed = function() {
	var _this = this;
	// prevent from instantiating directly?
};

/* sort of an abstract class */
mw.UploadWizardDeed.prototype = {
	isReady: function() {
		return false;
	},

	getSourceWikiText: function() {
		return $j( this.sourceInput ).val();
	},

	getAuthorWikiText: function() {
		return $j( this.authorInput ).val(); 
	},

	/**
	 * Get wikitext representing the licenses selected in the license object
	 * @return wikitext of all applicable license templates.
	 */
	getLicenseWikiText: function() {
		var _this = this;
		var wikiText = ''; 
		$j.each ( _this.licenseInput.getTemplates(), function( i, template ) {
			wikiText += "{{" + template + "}}\n";
		} );
	
		return wikiText;
	}

};

mw.ProgressBar = function( selector, text ) {
	var _this = this;
	// XXX need to figure out a way to put text inside bar

	_this.progressBarDiv = $j('<div></div>')
				.addClass("mwe-upwiz-progress-bar")
				.progressbar( { value: 0 } );

	_this.timeRemainingDiv = $j('<div></div>').addClass("mwe-upwiz-etr");

	_this.countDiv = $j('<div></div>').addClass("mwe-upwiz-count");

	_this.beginTime = undefined;
	
	$j( selector ).html( 
		$j('<div />').addClass( 'mwe-upwiz-progress' )
			.append( $j( '<div></div>' )
				.addClass( 'mwe-upwiz-progress-bar-etr' )
				.append( _this.progressBarDiv )
				.append( _this.timeRemainingDiv ) )
			.append( $j( _this.countDiv ) )
	);
			
};

mw.ProgressBar.prototype = {

	/**
	 * sets the beginning time (useful for figuring out estimated time remaining)
	 * if time parameter omitted, will set beginning time to now
	 *
	 * @param time  optional; the time this bar is presumed to have started (epoch milliseconds)
	 */ 
	setBeginTime: function( time ) {
		var _this = this;
		_this.beginTime = time ? time : ( new Date() ).getTime();
	},

	/**
	 * sets the total number of things we are tracking
	 * @param total an integer, for display e.g. uploaded 1 of 5, this is the 5
	 */ 
	setTotal: function(total) {
		var _this = this;
		_this.total = total;
	},	

	/**
	 * Show overall progress for the entire UploadWizard
	 * The current design doesn't have individual progress bars, just one giant one.
	 * We did some tricky calculations in startUploads to try to weight each individual file's progress against 
	 * the overall progress.
	 * @param fraction the amount of whatever it is that's done whatever it's done
	 */
	showProgress: function( fraction ) {
		var _this = this;

		_this.progressBarDiv.progressbar( 'value', parseInt( fraction * 100, 10 ) );

		var remainingTime;
		if (_this.beginTime === null) {
			remainingTime = 0;
		} else {	
			remainingTime = _this.getRemainingTime( fraction );
		}

		if ( remainingTime !== null ) {
			_this.timeRemainingDiv
				.html( gM( 'mwe-upwiz-remaining', mw.seconds2npt(parseInt(remainingTime / 1000), 10) ) );
		}
	},

	/**
	 * Calculate remaining time for all uploads to complete.
	 * 
	 * @param fraction	fraction of progress to show
	 * @return 		estimated time remaining (in milliseconds)
	 */
	getRemainingTime: function ( fraction ) {
		var _this = this;
		if ( _this.beginTime ) {
			var elapsedTime = ( new Date() ).getTime() - _this.beginTime;
			if ( fraction > 0.0 && elapsedTime > 0 ) { // or some other minimums for good data
				var rate = fraction / elapsedTime;
				return parseInt( ( 1.0 - fraction ) / rate, 10 ); 
			}
		}
		return null;
	},


	/**
	 * Show the overall count as we upload
	 * @param count  -- the number of items that have done whatever has been done e.g. in "uploaded 2 of 5", this is the 2
	 */
	showCount: function( count ) {
		var _this = this;
		_this.countDiv.html( gM( 'mwe-upwiz-upload-count', [ count, _this.total ] ) );
	}


};



//mw.setConfig('uploadHandlerClass', mw.MockUploadHandler); // ApiUploadHandler?

// available licenses should be a configuration of the MediaWiki instance,
// not hardcoded here.
// but, MediaWiki has no real concept of a License as a first class object -- there are templates and then specially - parsed 
// texts to create menus -- hack on top of hacks -- a bit too much to deal with ATM
/**
 * Create a group of checkboxes for licenses
 * @param div 
 * @param values  (optional) array of license key names to activate by default
 * @param change  (optional) function to execute when any value changes
 */
mw.UploadWizardLicenseInput = function( div, values ) {
	var _this = this;

	_this.change = function() {};

	var c = mw.UploadWizardLicenseInput.prototype.count++;

	// XXX get these for real
	_this.licenses = {
		pd:          { template: 'pd', text: 'Public Domain' },
		cc0:         { template: 'cc0', text: 'Creative Commons Zero waiver' },
		cc_by_30:    { template: 'cc-by-30', text: 'Creative Commons Attribution 3.0' },
		cc_by_sa_30: { template: 'cc-by-sa-30', text: 'Creative Commons Attribution ShareAlike 3.0' },
		gfdl:	     { template: 'gfdl', text: 'GFDL (GNU Free Documentation License)' }
	};

	_this.inputs = [];

	$div = $j( div );
	$j.each( _this.licenses, function( key, data ) {
		var id = 'license_' + key + '_' + c;
		var input = $j( '<input />' ) 
			.attr( { id: id, type: 'checkbox', value: key } )
			.click( function() { _this.change() } );
		data.input = input.get(0);
		$div.append( 
			data.input,
			$j( '<label />' ).attr( { 'for': id } ).html( data.text ),
			$j( '<br/>' )
		);
	} );

	if ( values ) {
		_this.setValues( values );
	}
};

mw.UploadWizardLicenseInput.prototype = {
	count: 0,

	/**
	 * Sets the value(s) of a license input.
	 * @param object of license-key to boolean values, e.g. { cc_by_sa_30: true, gfdl: true }
	 */
	setValues: function( licenseValues ) {
		var _this = this;
		$j.each( _this.licenses, function( key, data ) {
			var checked = ~~!!licenseValues[key];
			$j( _this.licenses[key].input ).attr( { 'checked' : checked } );
		} );
		_this.change();
	},

	/**
	 * Set the default configured licenses - should change per wiki
	 */
	setDefaultValues: function() {
		var _this = this;
		var values = {};
		$j.each( mw.getConfig('defaultLicenses'), function( i, license ) {
			values[license] = true;
		} );
		_this.setValues( values );
	},

	/**
	 * Gets which values are set to true
	 * @return object of object of license-key to boolean values, e.g. { cc_by_sa_30: true, gfdl: true }
	 */ 
	getValues: function() {
		var _this = this;
		var values = {};
		$j.each( _this.licenses, function( key, data ) {
			if ( $j( _this.licenses[key].input ).is( ':checked' ) ) {
				values[key] = data;
			} 
		} );
		return values;
	},

	/**
	 * Gets the templates associated with values set to true
	 * @return templates of licenses selected
  	 */
	getTemplates: function() {
		var _this = this;
		var templates = [];
		$j.each( _this.getValues(), function( key, data ) {
			templates.push( data.template );
		} );
		return templates;
	},

	/**
  	 * Returns true if any license is set
	 * @return boolean
	 */
	isSet: function() {
		var _this = this;
		return ( _this.getValues().length !== 0 );
	}

};


/**
 * Represents the upload -- in its local and remote state. (Possibly those could be separate objects too...)
 * This is our 'model' object if we are thinking MVC. Needs to be better factored, lots of feature envy with the UploadWizard
 * states:
 *   'new' 'transporting' 'transported' 'details' 'submitting-details' 'complete'  
 * should fork this into two -- local and remote, e.g. filename
 */
mw.UploadWizardUpload = function( filesDiv ) {
	var _this = this;
	_this.state = 'new';
	_this.transportWeight = 1;  // default
	_this.detailsWeight = 1; // default
	_this._thumbnails = {};
	_this.imageinfo = {};
	_this.title = undefined;
	_this.filename = undefined;
	_this.originalFilename = undefined;
	_this.mimetype = undefined;
	_this.extension = undefined;
		
	// details 		
	_this.ui = new mw.UploadWizardUploadInterface( _this, filesDiv );

	// handler -- usually ApiUploadHandler
	// _this.handler = new ( mw.getConfig( 'uploadHandlerClass' ) )( _this );
	// _this.handler = new mw.MockUploadHandler( _this );
	_this.handler = new mw.ApiUploadHandler( _this );
};

mw.UploadWizardUpload.prototype = {

	acceptDeed: function( deed ) {
		var _this = this;
		_this.deed.applyDeed( _this );
	},

	/**
 	 * start
	 */
	start: function() {
		var _this = this;
		_this.setTransportProgress(0.0);
		_this.handler.start();	
		_this.ui.start();
	},


	/**
	 * remove
	 */
	remove: function() {
		var _this = this;
		$j( _this.ui.div ).remove();
		$j( _this.details.div ).remove();
		$j( _this ).trigger( 'removeUpload' );
	},

	/**
	 * Wear our current progress, for observing processes to see
 	 * @param fraction
	 */
	setTransportProgress: function ( fraction ) {
		var _this = this;
		_this.state = 'transporting';
		_this.transportProgress = fraction;
		$j( _this ).trigger( 'transportProgressEvent' );
	},

	/**
	 * To be executed when an individual upload finishes. Processes the result and updates step 2's details 
	 * @param result	the API result in parsed JSON form
	 */
	setTransported: function( result ) {
		var _this = this;
		_this.state = 'transported';
		_this.transportProgress = 1;
		$j( _this ).trigger( 'transportedEvent' );

		if ( result.upload && result.upload.imageinfo && result.upload.imageinfo.descriptionurl ) {
			// success
			_this.extractUploadInfo( result );	
			_this.deedPreview.setup();
			_this.details.populate();
		
		} else if ( result.upload && result.upload.sessionkey ) {
			// there was a warning - type error which prevented it from adding the result to the db 
			if ( result.upload.warnings.duplicate ) {
				var duplicates = result.upload.warnings.duplicate;
				_this.details.errorDuplicate( result.upload.sessionkey, duplicates );
			}

			// and other errors that result in a stash
		} else if ( 0 /* actual failure */ ) {
			// we may want to tag or otherwise queue it as an upload to retry
		}
		
	
	},


	/**
	 * call when the file is entered into the file input
	 * get as much data as possible -- maybe exif, even thumbnail maybe
	 */
	extractLocalFileInfo: function( localFilename ) {
		var _this = this;
		if (false) {  // FileAPI, one day
			_this.transportWeight = getFileSize();
		}
		_this.extension = mw.UploadWizardUtil.getExtension( localFilename );
		// XXX add filename, original filename, extension, whatever else is interesting.
	},


	/** 
 	 * Accept the result from a successful API upload transport, and fill our own info 
	 *
	 * @param result The JSON object from a successful API upload result.
	 */
	extractUploadInfo: function( result ) {
		var _this = this;

		_this.filename = result.upload.filename;
		_this.title = mw.getConfig( 'fileNamespace' ) + ':' + _this.filename;

		_this.extractImageInfo( result.upload.imageinfo );

	},

	/**
	 * Extract image info into our upload object 	
	 * Image info is obtained from various different API methods
	 * @param imageinfo JSON object obtained from API result.
	 */
	extractImageInfo: function( imageinfo ) {
		var _this = this;
		for ( var key in imageinfo ) {
			// we get metadata as list of key-val pairs; convert to object for easier lookup. Assuming that EXIF fields are unique.
			if ( key == 'metadata' ) {
				_this.imageinfo.metadata = {};
				if ( imageinfo.metadata && imageinfo.metadata.length ) {
					$j.each( imageinfo.metadata, function( i, pair ) {
						if ( pair !== undefined ) {
							_this.imageinfo.metadata[pair['name'].toLowerCase()] = pair['value'];
						}
					} );
				}
			} else {
				_this.imageinfo[key] = imageinfo[key];
			}
		}
		
		// we should already have an extension, but if we don't... 
		if ( _this.extension === undefined ) {
			var extension = mw.UploadWizardUtil.getExtension( _this.imageinfo.url );
			if ( !extension ) {
				if ( _this.imageinfo.mimetype ) {
					if ( mw.UploadWizardUtil.mimetypeToExtension[ _this.imageinfo.mimetype ] ) {
						extension = mw.UploadWizardUtil.mimetypeToExtension[ _this.imageinfo.mimetype ];			
					} 
				}
			}
		}
	},

	/**
	 * Supply information to create a thumbnail for this Upload. Runs async, with a callback. 
	 * It is assumed you don't call this until it's been transported.
 	 *
	 * XXX should check if we really need this second API call or if we can get MediaWiki to make us a thumbnail URL upon upload
	 *
	 * @param width - desired width of thumbnail (height will scale to match)
	 * @param callback - callback to execute once thumbnail has been obtained -- must accept object with properties of width, height, and url.
	 */
	getThumbnail: function( width, callback ) {
		var _this = this;
		if ( _this._thumbnails[ "width" + width ] !== undefined ) {
			callback( _this._thumbnails[ "width" + width ] );
			return;
		}

		var apiUrl = mw.getLocalApiUrl();

		var params = {
                        'titles': _this.title,
                        'prop':  'imageinfo',
                        'iiurlwidth': width, 
                        'iiprop': 'url'
                };

		mw.getJSON( apiUrl, params, function( data ) {
			if ( !data || !data.query || !data.query.pages ) {
				mw.log(" No data? ");
				// XXX do something about the thumbnail spinner, maybe call the callback with a broken image.
				return;
			}

			if ( data.query.pages[-1] ) {
				// XXX do something about the thumbnail spinner, maybe call the callback with a broken image.
				return;
			}
			for ( var page_id in data.query.pages ) {
				var page = data.query.pages[ page_id ];
				if ( ! page.imageinfo ) {
					// not found? error
				} else {
					var imageInfo = page.imageinfo[0];
					var thumbnail = {
						width: 	imageInfo.thumbwidth,
						height: imageInfo.thumbheight,
						url: 	imageInfo.thumburl
					};
					_this._thumbnails[ "width" + width ] = thumbnail; 
					callback( thumbnail );
				}
			}
		} );

	},


	/**
	 *  look up thumbnail info and set it in HTML, with loading spinner
	 * it might be interesting to make this more of a publish/subscribe thing, since we have to do this 3x
	 * the callbacks may pile up, getting unnecessary info
	 *
	 * @param selector
	 * @param width
	 */
	setThumbnail: function( selector, width, imgClass ) {
		var _this = this;
		if ( typeof width === 'undefined' || width === null || width <= 0 )  {	
			width = mw.getConfig( 'thumbnailWidth' );
		}
		width = parseInt( width, 10 );

		if ( typeof imgClass === 'undefined' || imgClass === null ) {
			imgClass = 'mwe-upwiz-thumbnail';
		}
		
		var callback = function( thumbnail ) {
			// side effect: will replace thumbnail's loadingSpinner
			$j( selector ).html(
				$j('<a/>')
					.attr( { 'href': _this.imageinfo.descriptionurl,
						 'target' : '_new' } )
					.append(
						$j( '<img/>' )
							.addClass( imgClass )
							.attr( 'width',  thumbnail.width )
							.attr( 'height', thumbnail.height )
							.attr( 'src',    thumbnail.url ) ) );
		};

		$j( selector ).loadingSpinner();
		_this.getThumbnail( width, callback );
	}


	
};

/**
 * Create an interface fragment corresponding to a file input, suitable for Upload Wizard.
 * @param upload
 * @param div to insert file interface
 * @param addInterface interface to add a new one (assumed that we start out there)
 */
mw.UploadWizardUploadInterface = function( upload, filesDiv ) {
	var _this = this;

	_this.upload = upload;

	// may need to collaborate with the particular upload type sometimes
	// for the interface, as well as the uploadwizard. OY.
	_this.div = $j('<div class="mwe-upwiz-file"></div>').get(0);
	_this.isFilled = false;

	_this.fileInputCtrl = $j('<input size="1" class="mwe-upwiz-file-input" name="file" type="file"/>')
				.change( function() { _this.fileChanged(); } ) 
				.get(0);


	// XXX better class for helper, we probably have a standard already
	_this.visibleFilename = $j('<div class="mwe-upwiz-visible-file"></div>').hide();

	// XXX not sure if we will have a filename here -- we may want to autogenerate a "stashed" filename, 
	// with this flow
	_this.filenameCtrl = $j('<input type="hidden" name="filename" value=""/>').get(0); 
	
	// this file Ctrl container is placed over other interface elements, intercepts clicks and gives them to the file input control.
	// however, we want to pass hover events to interface elements that we are over, hence the bindings.
	// n.b. not using toggleClass because it often gets this event wrong -- relies on previous state to know what to do
	_this.fileCtrlContainer = $j('<div class="mwe-upwiz-file-ctrl-container">')
					.bind( 'mouseenter', function(e) { _this.addFileCtrlHover(e); } )
					.bind( 'mouseleave', function(e) { _this.removeFileCtrlHover(e); } );


	// the css trickery (along with css) 
	// here creates a giant size file input control which is contained within a div and then
	// clipped for overflow. The effect is that we have a div (ctrl-container) we can position anywhere
	// which works as a file input. It will be set to opacity:0 and then we can do whatever we want with
	// interface "below".
	// XXX caution -- if the add file input changes size we won't match, unless we add some sort of event to catch this.
	_this.form = $j('<form class="mwe-upwiz-form"></form>')
			.append( _this.visibleFilename )
			.append( _this.fileCtrlContainer
				.append( _this.fileInputCtrl ) 
			)
			.append( _this.filenameCtrl ).get( 0 );

	_this.progressMessage = $j('<span class="mwe-upwiz-status-message mwe-upwiz-file-indicator" style="display: none"></span>').get(0);


	_this.errorDiv = $j('<div class="mwe-upwiz-upload-error mwe-upwiz-file-indicator" style="display: none;"></div>').get(0);

	_this.removeCtrl = $j( '<div class="mwe-upwiz-file-indicator"><a title="' 
					+ gM( 'mwe-upwiz-remove-upload' ) 
					+ '" href="#" class="mwe-upwiz-remove">x</a></div>' )
				.click( function() { _this.upload.remove(); } )
				.hide()
				.get( 0 );


	$j( _this.div ).append( _this.form )
		    .append( _this.progressMessage )
		    .append( _this.errorDiv )
		    .append( _this.removeCtrl );

	// XXX evil hardcoded
	// we don't really need filesdiv if we do it this way?
	$j( _this.div ).insertBefore( '#mwe-upwiz-upload-ctrls' ); // append( _this.div );

	// _this.progressBar = ( no progress bar for individual uploads yet )
	// add a details thing to details
	// this should bind only to the FIRST transportProgress
	$j( upload ).bind( 'transportProgressEvent', function(e) { _this.showTransportProgress(); e.stopPropagation(); } );
	$j( upload ).bind( 'transportedEvent', function(e) { _this.showTransported(); e.stopPropagation(); } );

};


mw.UploadWizardUploadInterface.prototype = {
	/**
	 * Things to do to this interface once we start uploading
	 */
	start: function() {
		var _this = this;
		$j( _this.removeCtrl ).hide();
	},

	/**
	 * Make this interface look "busy" (i.e. spinner) without indicating a particular percentage of file uploaded.
	 * Will be useful for encoding phase of Firefogg, for example.
	 */
	busy: function() {
		var _this = this;
		// for now we implement this as looking like "100% progress"
		// e.g. an animated bar that takes up all the space
		_this.showTransportProgress( 1.0 );
	},

	/**
	 * Show progress by a fraction
	 * @param fraction	The fraction of progress. Float between 0 and 1
	 */
	showTransportProgress: function() {
		var _this = this;
		$j( _this.progressMessage ).addClass('mwe-upwiz-status-progress')
		    			   .html(gM( 'mwe-upwiz-uploading' ))
					   .show();
		// since, in this iteration of the interface, we never need to know 
		// about progress again, let's unbind
/*
		// unbind is broken in jquery 1.4.1 -- raises exception but it still works
		try { 
			$j( _this.upload ).unbind( 'transportProgressEvent' );
		} catch (ex) { }
*/		
		// update individual progress bar with fraction?
	},

	/**
	 * Execute when this upload is transported; cleans up interface. 
	 * @param result	AJAx result object
	 */
	showTransported: function() {
		var _this = this;
		$j( _this.progressMessage ).removeClass( 'mwe-upwiz-status-progress' )
					   .addClass( 'mwe-upwiz-status-completed' )
		   			   .html( gM( 'mwe-upwiz-transported' ) );
	},

	/**
	 * Run this when the value of the file input has changed. Check the file for various forms of goodness.
	 * If okay, then update the visible filename (due to CSS trickery the real file input is invisible)
	 */
	fileChanged: function() {
		var _this = this;
		_this.clearErrors();
		_this.upload.extractLocalFileInfo( $j( _this.fileInputCtrl ).val() );
		if ( _this.isGoodExtension( _this.upload.extension ) ) {
			_this.updateFilename();
		} else {       
			//_this.error( 'bad-filename-extension', ext );
			alert("bad extension");
		}
	},

	/**
	 * Move the file input to cover a certain element on the page. 
	 * We use invisible file inputs because this is the only way to style a file input
	 * or otherwise get it to do what you want.
	 * It is helpful to sometimes move them to cover certain elements on the page, and 
	 * even to pass events like hover
	 * @param selector jquery-compatible selector, for a single element
	 */
	moveFileInputToCover: function( selector ) {
		//mw.log( "moving to cover " + selector );
		var _this = this;
		var $covered = $j( selector ); 

		//mw.log( "position: " );
		//mw.log( $covered.position() );

		_this.fileCtrlContainer
			.css( $covered.position() ) 
			.width( $covered.outerWidth() )
			.height( $covered.outerHeight() );
		
		// shift the file input over with negative margins, 
		// internal to the overflow-containing div, so the div shows all button
		// and none of the textfield-like input
		$j( _this.fileInputCtrl ).css( {
			'margin-left': '-' + ~~( $j( _this.fileInputCtrl).width() - $covered.outerWidth() - 10 ) + 'px',
			'margin-top' : '-' + ~~( $j( _this.fileInputCtrl).height() - $covered.outerHeight() - 10 ) + 'px'
		} );

		// we may be passing the file ctrl's hover events to another covered interface element
		// see toggleFileCtrlHover
		if ( _this.fileCtrlCovered ) {
			_this.fileCtrlCovered.removeClass( 'hover' );
		}
		_this.fileCtrlCovered = $covered;

	},

	/**
	 * add class to an interface element covered by the fileCtrlContainer
	 * we are not using jQuery.toggleClass because it seems to get this wrong too often -- dumbly activates when should deactivate & 
	 * vice versa.
	 * @param jquery event
	 */
	addFileCtrlHover: function(e) {
		if ( this.fileCtrlCovered ) {
			this.fileCtrlCovered.addClass( 'hover' );
		}
	},

	/**
	 * remove class from an jquery-wrapped interface element covered by the fileCtrlContainer
	 * we are not using jQuery.toggleClass because it seems to get this wrong too often -- dumbly activates when should deactivate & 
	 * vice versa.
	 * @param jquery event
	 */
	removeFileCtrlHover: function(e) {
		if ( this.fileCtrlCovered ) {
			this.fileCtrlCovered.removeClass( 'hover' );
		}
	},


	/**
	 * this does two things: 
	 *   1 ) since the file input has been hidden with some clever CSS ( to avoid x-browser styling issues ), 
	 *      update the visible filename
	 *
	 *   2 ) update the filename desired when added to MediaWiki. This should be RELATED to the filename on the filesystem,
	 *      but it should be silently fixed so that it does not trigger uniqueness conflicts. i.e. if server has cat.jpg we change ours to cat_2.jpg.
	 *      This is hard to do in a scalable fashion on the client; we don't want to do 12 api calls to get cat_12.jpg. 
	 *      Ideally we should ask the SERVER for a decently unique filename related to our own. 
	 *	So, at the moment, this is hacked with a guaranteed - unique filename instead.  
	 */
	updateFilename: function() {
		var _this = this;
		var path = $j(_this.fileInputCtrl).attr('value');
		
	
		// visible filename	
		$j( _this.visibleFilename ).html( 
			'<span class="ui-icon ui-icon-document" style="display: inline-block;"></span> ' + path 
		);

		// desired filename 
		var filename = _this.convertPathToFilename( path );
		_this.upload.originalFilename = filename;
		// this is a hack to get a filename guaranteed unique.
		uniqueFilename = mw.getConfig( 'userName' ) + "_" + ( new Date() ).getTime() + "_" + filename;
		$j( _this.filenameCtrl ).attr( 'value', uniqueFilename );

		if ( ! _this.isFilled ) {
			_this.isFilled = true;
			$j( _this.div ).addClass( 'filled' );
			$j( _this.visibleFilename ).show();
			$j( _this.removeCtrl ).show();
			$j(_this.div ).css( { 
				'position': 'relative', // own our own file input; it will move with us now.
				'height': '24px'
			} );
			_this.moveFileInputToCover( _this.visibleFilename );
			$j( _this.upload ).trigger( 'filled' );
		} else {	
			$j( _this.upload ).trigger( 'filenameAccepted' );
		}
	},

	/**
	 * Remove any complaints we had about errors and such
	 * XXX this should be changed to something Theme compatible
	 */
	clearErrors: function() {
		var _this = this;
		$j( _this.div ).removeClass( 'mwe-upwiz-upload-error ');
		$j( _this.errorDiv ).hide().empty();
	},

	/**
	 * Show an error with the upload
	 */
	error: function() {
		var _this = this;
		var args = Array.prototype.slice.call( arguments ); // copies arguments into a real array
		var msg = 'mwe-upwiz-upload-error-' + args[0];
		$j( _this.errorDiv ).append( $j( '<p class="mwe-upwiz-upload-error">' + gM( msg, args.slice( 1 ) ) + '</p>') );
		// apply a error style to entire did
		$j( _this.div ).addClass( 'mwe-upwiz-upload-error' );
		$j( _this.errorDiv ).show();
	},

	/**
	 * Get the extension of the path in fileInputCtrl
	 * @return extension as string 
	 */
	getExtension: function() {
		var _this = this;
		var path = $j(_this.fileInputCtrl).attr('value');
		return mw.UploadWizardUtil.getExtension(path);
	},

	/**
	 * XXX this is common utility code
	 * used when converting contents of a file input and coming up with a suitable "filename" for mediawiki
	 * test: what if path is length 0 
	 * what if path is all separators
	 * what if path ends with a separator character
	 * what if it ends with multiple separator characters
	 *
	 * @param path
	 * @return filename suitable for mediawiki as string
	 */
	convertPathToFilename: function( path ) {
		if (path === undefined || path == '') {
			return '';
		}
		
 		var lastFileSeparatorIdx = Math.max(path.lastIndexOf( '/' ), path.lastIndexOf( '\\' ));
	 	// lastFileSeparatorIdx is now -1 if no separator found, or some index in the string.
		// so, +1, that is either 0 ( beginning of string ) or the character after last separator.
		// caution! could go past end of string... need to be more careful
		var filename = path.substr( lastFileSeparatorIdx + 1 );
		return mw.UploadWizardUtil.pathToTitle( filename );


	
 	},

	/**
	 * XXX this is common utility code
	 * copied because we'll probably need it... stripped from old doDestinationFill
	 * this is used when checking for "bad" extensions in a filename. 
	 * @param ext
	 * @return boolean if extension was acceptable
	 */
	isGoodExtension: function( ext ) {
		var _this = this;
		var found = false;
		var extensions = mw.getConfig('fileExtensions');
		if ( extensions ) {
			for ( var i = 0; i < extensions.length; i++ ) {
				if ( extensions[i].toLowerCase() == ext ) {
					found = true;
				}
			}
		}
		return found;
	}

};	
	
/**
 * Object that represents an indvidual language description, in the details portion of Upload Wizard
 * @param languageCode
 */
mw.UploadWizardDescription = function( languageCode ) {
	var _this = this;

	// Logic copied from MediaWiki:UploadForm.js
	// Per request from Portuguese and Brazilian users, treat Brazilian Portuguese as Portuguese.
	if (languageCode == 'pt-br') {
		languageCode = 'pt';
	// this was also in UploadForm.js, but without the heartwarming justification
	} else if (languageCode == 'en-gb') {
		languageCode = 'en';
	}

	_this.languageMenu = mw.LanguageUpWiz.getMenu("lang", languageCode);
	$j(_this.languageMenu).addClass('mwe-upwiz-desc-lang-select');
	_this.description = $j('<textarea name="desc" rows="2" cols="36" class="mwe-upwiz-desc-lang-text"></textarea>')
				.growTextArea().get(0);
	_this.div = $j('<div class="mwe-upwiz-desc-lang-container"></div>')
		       .append( _this.languageMenu )
	               .append( _this.description );
	
};

mw.UploadWizardDescription.prototype = {

	/**
	 * Obtain text of this description, suitable for including into Information template
	 * @return wikitext as a string
	 */
	getWikiText: function() {
		var _this = this;
		var language = $j( _this.languageMenu ).val().trim();
		var fix = mw.getConfig("languageTemplateFixups");
		if (fix[language]) {
			language = fix[language];
		}
		return '{{' + language + '|1=' + $j( _this.description ).val().trim() + '}}';
	}
};

/**
 * Object that represents the Details (step 2) portion of the UploadWizard
 * n.b. each upload gets its own details.
 * 
 * XXX a lot of this construction is not really the jQuery way. 
 * The correct thing would be to have some hidden static HTML
 * on the page which we clone and slice up with selectors. Inputs can still be members of the object
 * but they'll be found by selectors, not by creating them as members and then adding them to a DOM structure.
 *
 * XXX this should have styles for what mode we're in 
 *
 * @param UploadWizardUpload
 * @param containerDiv	The div to put the interface into
 */
mw.UploadWizardDetails = function( upload, containerDiv ) {

	var _this = this;
	_this.upload = upload;

	_this.descriptions = [];

	_this.div = $j( '<div class="mwe-upwiz-info-file"></div>' );

	_this.thumbnailDiv = $j( '<div class="mwe-upwiz-thumbnail"></div>' );
	
	_this.errorDiv = $j( '<div class="mwe-upwiz-details-error"></div>' );

	_this.dataDiv = $j( '<div class="mwe-upwiz-data"></div>' );

	// descriptions
	_this.descriptionsDiv = $j( '<div class="mwe-upwiz-details-descriptions mwe-upwiz-details-input"></div>' );
	

	_this.descriptionAdder = $j( '<a id="mwe-upwiz-desc-add"/>' )
					.attr( 'href', '#' )
					.html( gM( 'mwe-upwiz-desc-add-0' ) )
					.click( function( ) { _this.addDescription(); } );
	
	_this.descriptionsContainerDiv = 
		$j( '<div class="mwe-upwiz-details-descriptions-container"></div>' )
			.append( $j( '<div class="mwe-upwiz-details-label">' + gM( 'mwe-upwiz-desc' ) + '</div>' ) )
			.append( _this.descriptionsDiv )
			.append( $j( '<div class="mwe-upwiz-details-descriptions-add"></div>' )
					.append( _this.descriptionAdder ) );
	// Commons specific help for titles 
	//    http://commons.wikimedia.org/wiki/Commons:File_naming
	//    http://commons.wikimedia.org/wiki/MediaWiki:Filename-prefix-blacklist
	_this.titleInput = $j( '<textarea type="text" rows="1" class="mwe-title mwe-long-textarea"></textarea>' )
		.keyup( function() { 
			_this.setFilenameFromTitle();
		} )
		.growTextArea()
		.destinationChecked( {
			spinner: function(bool) { _this.toggleDestinationBusy(bool); },
			preprocess: function( name ) { return _this.getFilenameFromTitle(); }, // XXX this is no longer a pre-process
			processResult: function( result ) { _this.processDestinationCheck( result ); } 
		} );

	_this.titleErrorDiv = $j('<div></div>');

	_this.titleContainerDiv = $j('<div class="mwe-upwiz-details-label-input></div>')
		.append( $j( '<div class="mwe-upwiz-details-label"></div>' ).append( gM( 'mwe-upwiz-title' ) ) )
		.append( $j( '<div class="mwe-upwiz-details-input"></div>' ).append( _this.titleInput ) )
		.append( _this.titleErrorDiv );

	_this.deedDiv = $j( '<div class="mwe-upwiz-custom-deed" />' );

	_this.copyrightInfoFieldset = $j('<fieldset class="mwe-fieldset mwe-upwiz-copyright-info"></fieldset>')
		.hide()
		.append( 
			$j( '<legend class="mwe-legend">' ).append( gM( 'mwe-upwiz-copyright-info' ) ), 
			_this.deedDiv
		);
	
	_this.moreDetailsDiv = $j('<div class="mwe-more-details"></div>').maskSafeHide();

	_this.moreDetailsCtrlDiv = $j( '<div class="mwe-upwiz-details-more-options"></div>' );


	
	_this.dateInput = $j( '<input type="text" class="mwe-date" size="20"/>' );
	// XXX suddenly this isn't working. Seems to be a problem with monobook. If I datepicker-ify an input outside the 
	// content area, it works. Vector is fine
	$j( _this.dateInput ).datepicker( { 	
		dateFormat: 'yy-mm-dd', // oddly, this means yyyy-mm-dd
		buttonImage: mw.getMwEmbedPath() + 'skins/common/images/calendar.gif',
		buttonImageOnly: false  // XXX determine what this does, docs are confusing
	} );

	_this.locationInput = $j( '<input type="text" class="mwe-location" size="20"/>' );

	var aboutThisWorkFieldset = $j('<fieldset class="mwe-fieldset"></fieldset>')
		.append( $j( '<legend class="mwe-legend">' ).append( gM( 'mwe-upwiz-about-this-work' ) ) )
		.append( $j( '<div class="mwe-upwiz-details-more-subdiv">' )
			.append( $j( '<div class="mwe-upwiz-details-label-input"></div>' )
				.append( $j( '<div class="mwe-upwiz-details-more-label"></div>' ).append( gM( 'mwe-upwiz-date-created' ) ) )
				.append( $j( '<div class="mwe-upwiz-details-more-input"></div>' ).append( _this.dateInput ) ) 
			)
			.append( $j ( '<div style="display: none;"></div>' ) // see prefillLocation
				.append( $j( '<div class="mwe-upwiz-details-more-label"></div>' ).append( gM( 'mwe-upwiz-location' ) ) )
				.append( $j( '<div class="mwe-upwiz-details-more-input"></div>' ).append( _this.locationInput ) ) 
			)
		);



	var aboutFileFieldset = $j('<fieldset class="mwe-fieldset"></fieldset>')
		.append( $j( '<legend class="mwe-legend">' ).append( gM( 'mwe-upwiz-about-format' ) ) ) 
		.append( $j( '<div class="mwe-upwiz-details-more-subdiv">' )
			.append( $j( '<div></div>' )
				.append( $j( '<div class="mwe-upwiz-details-more-label"></div>' ).append( gM( 'mwe-upwiz-filename-tag' ) ) )
				.append( $j( '<div class="mwe-upwiz-details-filename mwe-upwiz-details-more-input"></div>' ) ) ) );
	
	_this.otherInformationInput = $j( '<textarea class="mwe-upwiz-other-textarea"></textarea>' );
	var otherInformationDiv = $j('<div></div>')	
		.append( $j( '<div class="mwe-upwiz-details-more-label">' ).append( gM( 'mwe-upwiz-other' ) ) ) 
		.append( _this.otherInformationInput );
	

	$j( _this.div )
		.addClass( 'ui-helper-clearfix' )
		.append( _this.thumbnailDiv )
		.append( _this.errorDiv )
		.append( $j( _this.dataDiv )
			.append( _this.descriptionsContainerDiv )
			.append( _this.titleContainerDiv )
			.append( _this.copyrightInfoFieldset )
			.append( _this.moreDetailsCtrlDiv )
			.append( $j( _this.moreDetailsDiv ) 
				.append( aboutThisWorkFieldset )
				//.append( aboutFileFieldset )
				.append( otherInformationDiv )
			)
		);

	mw.UploadWizardUtil.makeMoreToggler( _this.moreDetailsCtrlDiv, _this.moreDetailsDiv );	

	_this.addDescription();
	$j( containerDiv ).append( _this.div );


};

mw.UploadWizardDetails.prototype = {

	/**
	 * toggles whether we use the 'macro' deed or our own
	 */
	useCustomDeedChooser: function() {
		var _this = this;
		_this.copyrightInfoFieldset.show();
		_this.upload.wizardDeedChooser = _this.upload.deedChooser;
		_this.upload.deedChooser = new mw.UploadWizardDeedChooser( _this.deedDiv );
	},

	useDeedChooser: function( deedChooser ) {
		var _this = this;
		_this.upload.deedChooser = deedChooser;
		_this.deedDiv.empty();
	},


	/**
	 * Sets the filename from the title plus this upload's extension.
	 */
	setFilenameFromTitle: function() {
		var _this = this;
		_this.filename = mw.getConfig( 'fileNamespace' ) + ':' + _this.getFilenameFromTitle();
		$j( '#mwe-upwiz-details-filename' ).text( _this.filename );		
			
	},

	/**
	 * Gets a filename from the human readable title, using upload's extension.
	 * @return Filename
	 */ 
	getFilenameFromTitle: function() {
		var _this = this;
		var name = $j( _this.titleInput ).val();
		return mw.UploadWizardUtil.pathToTitle( name ) + '.' + _this.upload.extension;
	},


	/**
	 * show file destination field as "busy" while checking 
	 * @param busy boolean true = show busy-ness, false = remove
	 */
	toggleDestinationBusy: function ( busy ) {
		var _this = this;
		if (busy) {
			_this.titleInput.addClass( "busy" );
		} else {
			_this.titleInput.removeClass( "busy" );
		}
	},
	
	/**
	 * Process the result of a destination filename check.
	 * See mw.DestinationChecker.js for documentation of result format 
	 * XXX would be simpler if we created all these divs in the DOM and had a more jquery-friendly way of selecting
 	 * attrs. Instead we create & destroy whole interface each time. Won't someone think of the DOM elements?
	 * @param result
	 */
	processDestinationCheck: function( result ) {
		var _this = this;

		if ( result.isUnique ) {
			_this.titleErrorDiv.hide().empty();
			_this.ignoreWarningsInput = undefined;
			return;
		}

		// result is NOT unique
		var title = result.title;
		var img = result.img;
		var href = result.href;
	
		_this.ignoreWarningsInput = $j("<input />").attr( { type: 'checkbox', name: 'ignorewarnings' } ); 
	
		var $fileAlreadyExists = $j('<div />')
			.append(				
				gM( 'mwe-fileexists', 
					$j('<a />')
					.attr( { target: '_new', href: href } )
					.text( title )
				),
				$j('<br />'),
				_this.ignoreWarningsInput,
				gM('mwe-upwiz-overwrite')
			);
		
		var $imageLink = $j('<a />')
			.addClass( 'image' )
			.attr( { target: '_new', href: href } )
			.append( 
				$j( '<img />')
				.addClass( 'thumbimage' )
				.attr( {
					'width' : img.thumbwidth,
					'height' : img.thumbheight,
					'border' : 0,
					'src' : img.thumburl,
					'alt' : title
				} )
			);
			
		var $imageCaption = $j( '<div />' )
			.addClass( 'thumbcaption' )
			.append( 
				$j('<div />')
				.addClass( "magnify" )
				.append(
					$j('<a />' )
					.addClass( 'internal' )
					.attr( {
						'title' : gM('mwe-thumbnail-more'),
						'href' : href
					} ),
					
					$j( '<img />' )
					.attr( {
						'border' : 0,
						'width' : 15,
						'height' : 11,
						'src' : mw.getConfig( 'images_path' ) + 'magnify-clip.png'
					} ), 
					
					$j('<span />')
					.html( gM( 'mwe-fileexists-thumb' ) )
				)													
			);

		$j( _this.titleErrorDiv ).html(
			$j('<span />')  // dummy argument since .html() only takes one arg
				.append(
					$fileAlreadyExists,
					$j( '<div />' )
						.addClass( 'thumb tright' )
						.append(
							$j( '<div />' )
							.addClass( 'thumbinner' )
							.css({
								'width' : ( parseInt( img.thumbwidth ) + 2 ) + 'px;'
							})
							.append( 
								$imageLink, 
								$imageCaption
							)					
						)
				)
		).show();

	}, 

	/**
	 * Do anything related to a change in the number of descriptions
	 */
	recountDescriptions: function() {
		var _this = this;
		// if there is some maximum number of descriptions, deal with that here
		$j( _this.descriptionAdder ).html( gM( 'mwe-upwiz-desc-add-' + ( _this.descriptions.length == 0 ? '0' : 'n' )  )  );
	},


	/**
	 * Add a new description
	 */
	addDescription: function() {
		var _this = this;
		var languageCode = _this.descriptions.length ? mw.LanguageUpWiz.UNKNOWN : mw.getConfig('userLanguage' );
		var description = new mw.UploadWizardDescription( languageCode  );

		description.removeCtrl = $j('<a title="' + gM( 'mwe-upwiz-remove-description' ) + '" href="#">x</a>' )
					.addClass('mwe-upwiz-remove' )
					.addClass('mwe-upwiz-remove-desc' )
					.click( function() { _this.removeDescription( description  ) }  )
					.get( 0  );
		$j( description.div  ).append( description.removeCtrl  );

		$j( _this.descriptionsDiv ).append( description.div  );
		_this.descriptions.push( description  );
		_this.recountDescriptions();
	},

	/**
	 * Remove a description 
	 * @param description
	 */
	removeDescription: function( description  ) {
		var _this = this;
		$j( description.div ).remove();
		mw.UploadWizardUtil.removeItem( _this.descriptions, description  );
		_this.recountDescriptions();
	},

	/**
	 * Display an error with details
	 * XXX this is a lot like upload ui's error -- should merge
	 */
	error: function() {
		var _this = this;
		var args = Array.prototype.slice.call( arguments  ); // copies arguments into a real array
		var msg = 'mwe-upwiz-upload-error-' + args[0];
		$j( _this.errorDiv ).append( $j( '<p class="mwe-upwiz-upload-error">' + gM( msg, args.slice( 1 ) ) + '</p>' ) );
		// apply a error style to entire did
		$j( _this.div ).addClass( 'mwe-upwiz-upload-error' );
		$j( _this.dataDiv ).hide();
		$j( _this.errorDiv ).show();
	},

	/**
	 * Given the API result pull some info into the form ( for instance, extracted from EXIF, desired filename )
	 * @param result	Upload API result object
	 */
	populate: function() {
		var _this = this;
		mw.log( "populating details from upload" );
		_this.upload.setThumbnail( _this.thumbnailDiv );
		_this.prefillDate();
		_this.prefillSource();
		_this.prefillAuthor(); 
		_this.prefillTitle();
		_this.prefillFilename();
		_this.prefillLocation(); 
	},

	/**
	 * Check if we got an EXIF date back; otherwise use today's date; and enter it into the details 
	 * XXX We ought to be using date + time here...
	 * EXIF examples tend to be in ISO 8601, but the separators are sometimes things like colons, and they have lots of trailing info
	 * (which we should actually be using, such as time and timezone)
	 */
	prefillDate: function() {
		var _this = this;
		var yyyyMmDdRegex = /^(\d\d\d\d)[:\/-](\d\d)[:\/-](\d\d)\D.*/;
		var dateStr;
		var metadata = _this.upload.imageinfo.metadata;
		$j.each([metadata.datetimeoriginal, metadata.datetimedigitized, metadata.datetime, metadata['date']], 
			function( i, imageinfoDate ) {
				if ( imageinfoDate !== undefined ) {
					var d = imageinfoDate.trim();
					if ( d.match( yyyyMmDdRegex ) ) { 
						dateStr = d.replace( yyyyMmDdRegex, "$1-$2-$3" );
						return false; // break from $j.each
					}
				}
			}
		);
		// if we don't have EXIF or other metadata, let's use "now"
		// XXX if we have FileAPI, it might be clever to look at file attrs, saved 
		// in the upload object for use here later, perhaps
		function pad( n ) { 
			return n < 10 ? "0" + n : n;
		}

		if (dateStr === undefined) {
			d = new Date();
			dateStr = d.getUTCFullYear() + '-' + pad(d.getUTCMonth()) + '-' + pad(d.getUTCDate());
		}

		// ok by now we should definitely have a date string formatted in YYYY-MM-DD
		$j( _this.dateInput ).val( dateStr );
	},

	/**
	 * Set the title of the thing we just uploaded, visibly
	 * Note: the interface's notion of "filename" versus "title" is the opposite of MediaWiki
	 */
	prefillTitle: function() {
		var _this = this;
		var titleExt = mw.UploadWizardUtil.titleToPath( _this.upload.originalFilename );
		var title = titleExt.replace( /\.\w+$/, '' );
		$j( _this.titleInput ).val( title );
	},

	/**
	 * Set the title of the thing we just uploaded, visibly
	 * Note: the interface's notion of "filename" versus "title" is the opposite of MediaWiki
	 */
	prefillFilename: function() {
		var _this = this;
		_this.setFilenameFromTitle();
	},

	/**
 	 * Prefill location inputs (and/or scroll to position on map) from image info and metadata
	 *
	 * At least for my test images, the EXIF parser on MediaWiki is not giving back any data for
	 *  GPSLatitude, GPSLongitude, or GPSAltitudeRef. It is giving the lat/long Refs, the Altitude, and the MapDatum 
	 * So, this is broken until we fix MediaWiki's parser, OR, parse it ourselves somehow 
	 *
	 *    in Image namespace
	 *		GPSTag		Long ??
	 *
	 *    in GPSInfo namespace
	 *    GPSVersionID	byte*	2000 = 2.0.0.0
	 *    GPSLatitude	rational 
	 *    GPSLatitudeRef	ascii (N | S)  or North | South 
	 *    GPSLongitude	rational
	 *    GPSLongitudeRef   ascii (E | W)    or East | West 
	 *    GPSAltitude	rational
	 *    GPSAltitudeRef	byte (0 | 1)    above or below sea level
	 *    GPSImgDirection	rational
	 *    GPSImgDirectionRef  ascii (M | T)  magnetic or true north
	 *    GPSMapDatum 	ascii		"WGS-84" is the standard
	 *
	 *  A 'rational' is a string like this:
	 *	"53/1 0/1 201867/4096"	--> 53 deg  0 min   49.284 seconds 
	 *	"2/1 11/1 64639/4096"    --> 2 deg  11 min  15.781 seconds
	 *	"122/1"             -- 122 m  (altitude)
	 */
	prefillLocation: function() {
		var _this = this;
		var metadata = _this.upload.imageinfo.metadata;
		if (metadata === undefined) {
			return;
		}
		

	},

	/**
	 * Given a decimal latitude and longitude, return filled out {{Location}} template
	 * @param latitude decimal latitude ( -90.0 >= n >= 90.0 ; south = negative )
	 * @param longitude decimal longitude ( -180.0 >= n >= 180.0 ; west = negative )
	 * @param scale (optional) how rough the geocoding is. 
	 * @param heading (optional) what direction the camera is pointing in. (decimal 0.0-360.0, 0 = north, 90 = E)
	 * @return string with WikiText which will geotag this record
	 */
	coordsToWikiText: function(latitude, longitude, scale, heading) {
		//Wikipedia
		//http://en.wikipedia.org/wiki/Wikipedia:WikiProject_Geographical_coordinates#Parameters
		// http://en.wikipedia.org/wiki/Template:Coord
		//{{coord|61.1631|-149.9721|type:landmark_globe:earth_region:US-AK_scale:150000_source:gnis|name=Kulis Air National Guard Base}}
		
		//Wikimedia Commons
		//{{Coor dms|41|19|20.4|N|19|38|36.7|E}}
		//{{Location}}

	},

	/**
	 * If there is a way to figure out source from image info, do so here
	 * XXX user pref?
	 */
	prefillSource: function() {
		// we have no way to do this AFAICT
	},

	/**
	 * Prefill author (such as can be determined) from image info and metadata
	 * XXX user pref?
	 */
	prefillAuthor: function() {
		var _this = this;
		if (_this.upload.imageinfo.metadata.author !== undefined) {
			$j( _this.authorInput ).val( _this.upload.imageinfo.metadata.author );
		}
	
	},
	
	/**
	 * Prefill license (such as can be determined) from image info and metadata
	 * XXX user pref?
	 */
	prefillLicense: function() {
		var _this = this;
		var copyright = _this.upload.imageinfo.metadata.copyright;
		if (copyright !== undefined) {
			if (copyright.match(/\bcc-by-sa\b/i)) {
				// set license to be that CC-BY-SA
			} else if (copyright.match(/\bcc-by\b/i)) {
				// set license to be that
			} else if (copyright.match(/\bcc-zero\b/i)) {
				// set license to be that
				// XXX any other licenses we could guess from copyright statement
			} else {
				$j( _this.licenseInput ).val( copyright );
			}
		}
	},


	/**
	 * 
	showErrors: function() {
		var _this = this;
		$j.each( _this.errors, function() {

		} );
	},
	 */
	
	/**
	 * Convert entire details for this file into wikiText, which will then be posted to the file 
	 * XXX there is a WikiText sanitizer in use on UploadForm -- use that here, or port it 
	 * @return wikitext representing all details
	 */
	getWikiText: function() {
		var _this = this;
		
		// XXX validate!
		if ( ! _this.isReady() ) {
			alert( "ZOMG THIS DEED IS NOT READY" );
			return null;
		}



		wikiText = '';
	

		// http://commons.wikimedia.org / wiki / Template:Information
	
		// can we be more slick and do this with maps, applys, joins?
		var information = { 
			'description' : '',	 // {{lang|description in lang}}*   required
			'date' : '',		 // YYYY, YYYY-MM, or YYYY-MM-DD     required  - use jquery but allow editing, then double check for sane date.
			'source' : '',    	 // {{own}} or wikitext    optional 
			'author' : '',		 // any wikitext, but particularly {{Creator:Name Surname}}   required
			'permission' : '',       // leave blank unless OTRS pending; by default will be "see below"   optional 
			'other_versions' : '',   // pipe separated list, other versions     optional
			'other_fields' : ''      // ???     additional table fields 
		};
		
		// sanity check the descriptions -- do not have two in the same lang
		// all should be a known lang
		if ( _this.descriptions.length === 0 ) {
			// ruh roh
			// we should not even allow them to press the button ( ? ) but then what about the queue...
		}
		$j.each( _this.descriptions, function( i, desc ) {
			information['description'] += desc.getWikiText();
		} );	

		// XXX add a sanity check here for good date
		information['date'] = $j( _this.dateInput ).val().trim();

		var deed = _this.upload.deedChooser.deed;

		information['source'] = deed.getSourceWikiText();

		information['author'] = deed.getAuthorWikiText();
		
		var info = '';
		for ( var key in information ) {
			info += '|' + key + '=' + information[key] + "\n";	
		}	

		wikiText += "=={{int:filedesc}}==\n";

		wikiText += '{{Information\n' + info + '}}\n';

	
		wikiText += "=={{int:license-header}}==\n";
		
		wikiText += deed.getLicenseWikiText();

		// add a location template

		// add an "anything else" template if needed
		var otherInfoWikiText = $j( _this.otherInformationInput ).val().trim();
		if ( otherInfoWikiText != '' ) {
			wikiText += "=={{int:otherinfo}}==\n";
			wikiText += otherInfoWikiText;
		}

		return wikiText;	
	},

	/**
	 * Check if we are ready to post wikitext
	 */
	isReady: function() {
		var _this = this;
		return _this.upload.deedChooser.deed.isReady();

		// somehow, all the various issues discovered with this upload should be present in a single place
		// where we can then check on
		// perhaps as simple as _this.issues or _this.agenda
	},

	/**
	 * Post wikitext as edited here, to the file
	 * XXX This should be split up -- one part should get wikitext from the interface here, and the ajax call
	 * should be be part of upload
	 */
	submit: function() {
		var _this = this;


		// are we okay to submit?
		// all necessary fields are ready
		// check descriptions
		// the filename is in a sane state
		var desiredFilename = _this.filename;
		shouldRename = ( desiredFilename != _this.upload.title );

		// if ok to go			
		// XXX lock down the interface, spinnerify
		// else
		// point out problems


		// XXX check state of details for okayness ( license selected, at least one desc, sane filename )
		var wikiText = _this.getWikiText();
		mw.log( wikiText );
	
		var params = {
			action: 'edit',
			token: mw.getConfig( 'token' ),
			title: _this.upload.title,
			// section: 0, ?? causing issues?
			text: wikiText,
			summary: "User edited page with " + mw.UploadWizard.userAgent,
			// notminor: 1,
			// basetimestamp: _this.upload.imageinfo.timestamp,  ( conflicts? )
			nocreate: 1
		};

		var endCallback = function() { _this.completeDetailsSubmission(); }	

		mw.log( "editing!" );
		mw.log( params );
		var callback = function( result ) {
			mw.log( result );
			mw.log( "successful edit" );
			if ( shouldRename ) {
				_this.rename( desiredFilename, endCallback );	
			} else {
				endCallback();
			}
		};

		_this.upload.state = 'submitting-details';
		_this.showProgress();
		mw.getJSON( params, callback );
	},

	/**
	 * Rename the file
         *
	 *  THIS MAY NOT WORK ON ALL WIKIS. for instance, on Commons, it may be that only admins can move pages. This is another example of how
	 *  we need an "incomplete" upload status
	 *  we are presuming this File page is brand new, so let's not bother with the whole redirection deal. ('noredirect')
	 *
	 * use _this.ignoreWarningsInput (if it exists) to check if we can blithely move the file or if we have a problem if there
	 * is a file by that name already there
	 *
	 * @param filename to rename this file to
 	 */
	rename: function( title, endCallback ) {
		var _this = this;
		mw.log("renaming!");
		params = {
			action: 'move',
			from: _this.upload.title,
			to: title,
			reason: "User edited page with " + mw.UploadWizard.userAgent,
			movetalk: '',
			noredirect: '', // presume it's too new 
			token: mw.getConfig('token')
		};
		mw.log(params);
		// despite the name, getJSON magically changes this into a POST request (it has a list of methods and what they require).
		mw.getJSON( params, function( data ) {
			// handle errors later
			// possible error data: { code = 'missingtitle' } -- orig filename not there
			// and many more
	
			// which should match our request.
			// we should update the current upload filename
			// then call the uploadwizard with our progress

			// success is
			// { move = { from : ..., reason : ..., redirectcreated : ..., to : .... }
			if (data !== undefined && data.move !== undefined && data.move.to !== undefined) {
				_this.upload.title = data.move.to;
				_this.refreshImageInfo( _this.upload, _this.upload.title, endCallback );
			}
		} );
	},

	/** 
	 * Get new image info, for instance, after we renamed an image
	 *
	 * @param upload an UploadWizardUpload object
	 * @param title  title to look up remotely
	 * @param endCallback  execute upon completion
	 */
	refreshImageInfo: function( upload, title, endCallback ) {
		var params = {
                        'titles': title,
                        'prop':  'imageinfo',
                        'iiprop': 'timestamp|url|user|size|sha1|mime|metadata'
                };
		// XXX timeout callback?
		mw.getJSON( params, function( data ) {
			if ( data && data.query && data.query.pages ) {
				if ( ! data.query.pages[-1] ) {
					for ( var page_id in data.query.pages ) {
						var page = data.query.pages[ page_id ];
						if ( ! page.imageinfo ) {
							// not found? error
						} else {
							upload.extractImageInfo( page.imageinfo[0] );
						}
					}
				}	
			}
			endCallback();
		} );
	},

	showProgress: function() {
		var _this = this;
		_this.div.mask();
		// XXX spinnerize
		_this.upload.detailsProgress = 1.0;
	},

	completeDetailsSubmission: function() {
		var _this = this;
		_this.upload.state = 'complete';
		// XXX de-spinnerize
		_this.div.unmask();
	}
		
};


/**
 * Object that reperesents the entire multi-step Upload Wizard
 */
mw.UploadWizard = function() {

	this.uploads = [];

};


mw.UploadWizard.userAgent = "UploadWizard (alpha) on " + $j.browser.name + " " + $j.browser.version;


mw.UploadWizard.prototype = {
	maxUploads: 10,  // XXX get this from config 
	maxSimultaneousUploads: 2,   //  XXX get this from config
	stepNames: [ 'file', 'deeds', 'details', 'thanks' ],
	currentStepName: undefined,

	/*
	// list possible upload handlers in order of preference
	// these should all be in the mw.* namespace
	// hardcoded for now. maybe some registry system might work later, like, all
	// things which subclass off of UploadHandler
	uploadHandlers: [
		'FirefoggUploadHandler',
		'XhrUploadHandler',
		'ApiIframeUploadHandler',
		'SimpleUploadHandler',
		'NullUploadHandler'
	],

	 * We can use various UploadHandlers based on the browser's capabilities. Let's pick one.
	 * For example, the ApiUploadHandler should work just about everywhere, but XhrUploadHandler
	 *   allows for more fine-grained upload progress
	 * @return valid JS upload handler class constructor function
	getUploadHandlerClass: function() {
		// return mw.MockUploadHandler;
		return mw.ApiUploadHandler;
		var _this = this;
		for ( var i = 0; i < uploadHandlers.length; i++ ) {
			var klass = mw[uploadHandlers[i]];
			if ( klass != undefined && klass.canRun( this.config )) {
				return klass;
			}
		}
		// this should never happen; NullUploadHandler should always work
		return null;
	},
	*/

	reset: function() {
		var _this = this;
		$j.each( _this.uploads, function( i, upload ) {
			_this.removeUpload( upload );
		} );
		_this.uploads = [];
	},

	
	/**
	 * create the basic interface to make an upload in this div
	 * @param div	The div in the DOM to put all of this into.
	 */
	createInterface: function( selector ) {
		var _this = this;
		var div = $j( selector ).get(0);
		div.innerHTML = 
	
		         '<div id="mwe-upwiz-steparrows" class="ui-helper-clearfix">'
		       +   '<ul>'
		       +     '<li id="mwe-upwiz-step-file"><span class="mwe-arrow-text">'     + gM('mwe-upwiz-step-file')     + '<span class="mwe-arrow"/></span></span></li>'
		       +     '<li id="mwe-upwiz-step-deeds"><span class="mwe-arrow-text">'  + gM('mwe-upwiz-step-deeds')  + '<span class="mwe-arrow"/></span></span></li>'
		       +     '<li id="mwe-upwiz-step-details"><span class="mwe-arrow-text">'  + gM('mwe-upwiz-step-details')  + '<span class="mwe-arrow"/></span></span></li>'
		       +     '<li id="mwe-upwiz-step-thanks"><span class="mwe-arrow-text">'   + gM('mwe-upwiz-step-thanks')   + '<span class="mwe-arrow"/></span></span></li>'
		       +   '</ul>'	
		       + '</div>'

		       + '<div id="mwe-upwiz-content">'

		       +   '<div class="mwe-upwiz-stepdiv ui-helper-clearfix" id="mwe-upwiz-stepdiv-file">'
		       +     '<div id="mwe-upwiz-intro">' + gM('mwe-upwiz-intro') + '</div>'
		       +     '<div id="mwe-upwiz-files">'
		       +       '<div class="shim" style="height: 120px"></div>'
		       +       '<div id="mwe-upwiz-upload-ctrls" class="mwe-upwiz-file">'
		       +          '<div id="mwe-upwiz-add-file-container" class="mwe-upwiz-add-files-0">'
		       +            '<a id="mwe-upwiz-add-file">' + gM("mwe-upwiz-add-file-0") + '</a>'
		       +	  '</div>'
		       +          '<div id="proceed" class="mwe-upwiz-file-indicator" style="display: none;">'
		       +            '<button id="mwe-upwiz-upload-ctrl" disabled="disabled">' + gM("mwe-upwiz-upload") + '</button>'
		       +          '</div>'
		       +       '</div>'
		       +       '<div id="mwe-upwiz-progress" class="ui-helper-clearfix"></div>'
		       +     '</div>'
		       +     '<div class="mwe-upwiz-buttons"/>'
		       +        '<button class="mwe-upwiz-button-next" />'
		       +     '</div>'
		       +   '</div>'

		       +   '<div class="mwe-upwiz-stepdiv" id="mwe-upwiz-stepdiv-deeds">'
		       +     '<div id="mwe-upwiz-deeds-intro"></div>'
		       +     '<div id="mwe-upwiz-deeds-thumbnails" class="ui-helper-clearfix"></div>'
		       +     '<div id="mwe-upwiz-deeds" class="ui-helper-clearfix"></div>'
		       +     '<div id="mwe-upwiz-deeds-custom" class="ui-helper-clearfix"></div>'
		       +     '<div class="mwe-upwiz-buttons"/>'
		       +        '<button class="mwe-upwiz-button-next" />'
		       +     '</div>'
                       +   '</div>'

		       +   '<div class="mwe-upwiz-stepdiv" id="mwe-upwiz-stepdiv-details">'
		       +     '<div id="mwe-upwiz-macro">'
		       +       '<div id="mwe-upwiz-macro-progress" class="ui-helper-clearfix"></div>'
		       +       '<div id="mwe-upwiz-macro-choice">' 
		       +  	 '<div>' + gM( 'mwe-upwiz-details-intro' ) + '</div>'
		       +       '</div>'
		       +       '<div id="mwe-upwiz-macro-files"></div>'
		       +     '</div>'
		       +     '<div class="mwe-upwiz-buttons"/>'
		       +        '<button class="mwe-upwiz-button-next" />'
		       +     '</div>'
		       +   '</div>'

		       +   '<div class="mwe-upwiz-stepdiv" id="mwe-upwiz-stepdiv-thanks">'
		       +     '<div id="mwe-upwiz-thanks"></div>'
		       +     '<div class="mwe-upwiz-buttons"/>'
		       +        '<button class="mwe-upwiz-button-begin"></button>'
		       +        '<br/><button class="mwe-upwiz-button-home"></button>'
		       +     '</div>'		
                       +   '</div>'

		       + '</div>'

		       + '<div class="mwe-upwiz-clearing"></div>';
		

		$j( '.mwe-upwiz-button-home' )
			.append( gM( 'mwe-upwiz-home' ) )
			.click( function() { window.location.href = '/' } );
		
		$j( '.mwe-upwiz-button-begin' )
			.append( gM( 'mwe-upwiz-upload-another' ) )
			.click( _this.reset() );
		
		$j( '.mwe-upwiz-button-next' )
			.append( gM( 'mwe-upwiz-next' ) )

		// within FILE step div
		$j('#mwe-upwiz-upload-ctrl').click( function() { 
			_this.removeEmptyUploads();
			_this.startUploads(); 
		} );

		$j( '#mwe-upwiz-stepdiv-file .mwe-upwiz-button-next').click( function() {
			_this.moveToStep( 'deeds' );
		} );

		// DEEDS div
		_this.deedChooser = new mw.UploadWizardDeedChooser( '#mwe-upwiz-deeds' );

		var customDeed = $j.extend( new mw.UploadWizardDeed(), {
			isReady: function() { return true; },
			setQuantity: function( n ) { return; }
		} );

		$j( '#mwe-upwiz-deeds-custom' ).append( 
			$j( '<div id="mwe-upwiz-deeds-later" />' )
				.hide()
				.append( $j( '<label>' )
					.append( 
						$j( '<input />')
							.attr( { type: 'checkbox', value: 'deeds-later' } )
							.addClass( 'mwe-accept-deed' )
							.click( function() {
								if ( $j( this ).is( ':checked' ) ) {
									_this.deedChooser.showDeedChoice();
									_this.deedChooser.choose( customDeed );
									//_this.deedChooser.trigger( 'isReady' );
								} else {
									_this.deedChooser.choose( mw.UploadWizardNullDeed );
								}
							} ),
						$j( '<span />').append( gM( 'mwe-upwiz-deeds-later' ) )
					)
				)
		);
		
		$j( _this.deedChooser ).bind( 'setQuantityEvent', function() {
			mw.log( "checking this deedchooser count " + _this.deedChooser.count );
			if ( _this.deedChooser.count > 1 ) {
				$j( '#mwe-upwiz-deeds-later' ).show();
			} else {
				$j( '#mwe-upwiz-deeds-later' ).hide();
			}
		} );

		$j( '#mwe-upwiz-deeds-intro' ).html( gM( 'mwe-upwiz-deeds-intro' ) );

		$j( '#mwe-upwiz-stepdiv-deeds .mwe-upwiz-button-next').click( function() {
			_this.moveToStep('details');
		} );

		// XXX perhaps we should defer this until we click next
		$j( _this.deedChooser ).bind( 'chooseDeed', function() {
			var isCustom = ( _this.deedChooser.deed === customDeed );
			$j.each( _this.uploads, function( i, upload ) {
				if (isCustom) {
					upload.details.useCustomDeedChooser();
				} else {
					upload.details.useDeedChooser( _this.deedChooser );
				}
			} );
		} ); 

		// XXX perhaps we should defer this until we click next
		$j( _this.deedChooser ).bind( 'chooseNullDeed', function() {
			$j.each( _this.uploads, function( i, upload ) {
				upload.details.deedChooser = _this.deedChooser;
			} );
			// $j( '#mwe-upwiz-stepdiv-deeds' ).disableNextButton();
		} );

	/*
		// XXX figure out some way to make them ready / unready
		// timeout after input, check for readiness, then trigger event?
		$j( _this.deedChooser ).bind( 'isReady', function() {
			$j( '#mwe-upwiz-stepdiv-deeds' ).enableNextButton();
		} );

		$j( _this.deedChooser ).bind( 'isNotReady', function() {
			$j( '#mwe-upwiz-stepdiv-deeds' ).disableNextButton();
		} );
*/

		// DETAILS div
		$j( '#mwe-upwiz-stepdiv-details .mwe-upwiz-button-next' ).click( function() {
			_this.detailsSubmit( function() { 
				_this.prefillThanksPage();
				_this.moveToStep('thanks');
			} );
		} );
	
		// add one to start
		var upload = _this.newUpload( '#mwe-upwiz-add-file' );

		// "select" the first step - highlight, make it visible, hide all others
		_this.moveToStep( 'file', function() { 
			// XXX moving the file input doesn't seem to work at this point; we get its old position before
			// CSS is applied. Hence, using a timeout.
			// XXX using a timeout is lame, are there other options?
			// XXX Trevor suggests that using addClass() may queue stuff unnecessarily; use 'concrete' HTML
			setTimeout( function() {	
				upload.ui.moveFileInputToCover( '#mwe-upwiz-add-file' );
			}, 300 );
		} );

	},

	/**
	 * Advance one "step" in the wizard interface.
	 * It is assumed that the previous step to the current one was selected.
	 * We do not hide the tabs because this messes up certain calculations we'd like to make about dimensions, while elements are not 
	 * on screen. So instead we make the tabs zero height and, in CSS, they are already overflow hidden
	 * @param selectedStepName
	 * @param callback to do after layout is ready?
	 */
	moveToStep: function( selectedStepName, callback ) {
		var _this = this;
		$j.each( _this.stepNames, function(i, stepName) {
			
			// the step indicator	
			var step = $j( '#mwe-upwiz-step-' + stepName );
			
			// the step's contents
			var stepDiv = $j( '#mwe-upwiz-stepdiv-' + stepName );

			if ( _this.currentStepName == stepName ) {
				// we hide the old stepDivs because we are afraid of some z-index elements that may interfere with later tabs
				// this will break if we ever allow people to page back and forth.
				step.hide( 1000 );
				stepDiv.hide();
			} else if ( selectedStepName == stepName ) {
				stepDiv.maskSafeShow();
				step.addClass( 'mwe-upwiz-step-highlight' );
			} else {
				// it's neither the formerly active nor the newly active one, so don't show it
				// we don't use hide() because we want to manipulate elements within future tabs, and calculate their dimensions.
				// stepDiv.maskSafeHide();
			}
		} );

		_this.currentStepName = selectedStepName;

		$j.each( _this.uploads, function(i, upload) {
			upload.state = selectedStepName;
		} );

		if ( callback ) {
			callback();
		}
	},

	/**
	 * add an Upload
	 *   we create the upload interface, a handler to transport it to the server,
	 *   and UI for the upload itself and the "details" at the second step of the wizard.
	 *   we don't yet add it to the list of uploads; that only happens when it gets a real file.
	 * @return boolean success
	 */
	newUpload: function() {
		var _this = this;
		if ( _this.uploads.length == _this.maxUploads ) {
			return false;
		}

		var upload = new mw.UploadWizardUpload( _this, '#mwe-upwiz-files' );
		_this.uploadToAdd = upload;

		upload.ui.moveFileInputToCover( '#mwe-upwiz-add-file' );
		$j( upload ).bind( 'filenameAccepted', function(e) { _this.updateFileCounts();  e.stopPropagation(); } );
		$j( upload ).bind( 'removeUpload', function(e) { _this.removeUpload( upload ); e.stopPropagation(); } );
		$j( upload ).bind( 'filled', function(e) { 
			_this.newUpload(); 
			_this.setUploadFilled(upload);
			e.stopPropagation(); 
		} );
		// XXX bind to some error state

	
		return upload;
	},

	/**
	 * When an upload is filled with a real file, accept it in the wizard's list of uploads
	 * and set up some other interfaces
	 * @param UploadWizardUpload
	 */
	setUploadFilled: function( upload ) {
		var _this = this;
		
		// XXX check if it has a file? 

		_this.uploads.push( upload );
		_this.updateFileCounts();
		
		upload.deedPreview = new mw.UploadWizardDeedPreview( upload );	
	
		// this will modify upload, so it has a .deedChooser property.
		// We use a method to so we notify deedChooser that it has a new upload -- interface
		// will change based on quantity etc. Maybe we could be clever with bind here.
		_this.deedChooser.attach( upload );
	
		// set up details
		upload.details = new mw.UploadWizardDetails( upload, $j( '#mwe-upwiz-macro-files' ));
	},


	/**
	 * Remove an upload from our array of uploads, and the HTML UI 
	 * We can remove the HTML UI directly, as jquery will just get the parent.
         * We need to grep through the array of uploads, since we don't know the current index. 
	 * We need to update file counts for obvious reasons.
	 *
	 * @param upload
	 */
	removeUpload: function( upload ) {
		var _this = this;
		$j( upload ).unbind(); // everything
		if ( upload.deedChooser ) {
			upload.deedChooser.detach( upload );
		}
		upload.details.div.remove();
		upload.thanksDiv.remove();

		mw.UploadWizardUtil.removeItem( _this.uploads, upload );
		_this.updateFileCounts();
	},

	/**
	 * This is useful to clean out unused upload file inputs if the user hits GO.
	 * We are using a second array to iterate, because we will be splicing the main one, _this.uploads
	 */
	removeEmptyUploads: function() {
		var _this = this;
		var toRemove = [];

		for ( var i = 0; i < _this.uploads.length; i++ ) {
			if ( _this.uploads[i].ui.fileInputCtrl.value == "" ) {
				toRemove.push( _this.uploads[i] );
			}
		}

		for ( var i = 0; i < toRemove.length; i++ ) {
			toRemove[i].remove();
		}
	},

	/**
	 * Manage transitioning all of our uploads from one state to another -- like from "new" to "uploaded".
 	 * Shows progress bar with estimated time remaining.
	 *
	 * There are too many args here. How to fix?
	 * This is starting to feel like an object.
	 *
	 * @param beginState   what state the upload should be in before starting.
	 * @param progressState  the state to set the upload to while it's doing whatever 
	 * @param endState   the state to set the upload to after it's done whatever 
	 * @param progressProperty  the property on the upload showing current progress of whatever
	 * @param weightProperty    the property on the upload giving how heavy to weight this item in total progress calculation
	 * @param  starter	 function, taking single argument (upload) which starts the process we're interested in 
	 * @param progressBarSelector where to put the progress bar
	 * @param endCallback    function to call when all uploads are in the end state.
	 */
	makeTransitioner: function( beginState, 
				    progressState, 
				    endState, 
				    progressProperty, 
				    weightProperty, 
				    progressBarSelector,
				    progressBarText,	
				    starter, 
				    endCallback ) {
		
		var wizard = this;

		var totalWeight = 0.0;
		$j.each( wizard.uploads, function( i, upload ) {
			totalWeight += upload[weightProperty];
		} );
		var totalCount = wizard.uploads.length;

		var progressBar = new mw.ProgressBar( progressBarSelector, progressBarText );
		progressBar.setTotal( totalCount );

		transitioner = function() {
			var fraction = 0.0;
			var uploadsToStart = wizard.maxSimultaneousUploads;
			var endStateCount = 0;
			$j.each( wizard.uploads, function(i, upload) {
				if ( upload.state == endState ) {
					endStateCount++;
				} else if ( upload.state == progressState ) {
					uploadsToStart--;
				} else if ( ( upload.state == beginState ) && ( uploadsToStart > 0 ) ) {
					starter( upload );
					uploadsToStart--;
				}
				if (upload[progressProperty] !== undefined) {
					fraction += upload[progressProperty] * ( upload[weightProperty] / totalWeight );
				}
			} );

			// perhaps this could be collected into a single progressbar obj
			progressBar.showProgress( fraction );
			progressBar.showCount( endStateCount );
	
			// build in a little delay even for the end state, so user can see progress bar in a complete state.	
			var nextAction = (endStateCount == totalCount) ? endCallback : transitioner;
			setTimeout( nextAction, wizard.transitionerDelay );
		};

		progressBar.setBeginTime();
		transitioner();
	},

	transitionerDelay: 300,  // milliseconds

		

	/**
	 * Kick off the upload processes.
	 * Does some precalculations, changes the interface to be less mutable, moves the uploads to a queue, 
	 * and kicks off a thread which will take from the queue.
	 */
	startUploads: function( finishedCallback ) {
		var _this = this;
		// remove the upload button, and the add file button
		$j( '#mwe-upwiz-upload-ctrl' ).hide();
		$j( '#mwe-upwiz-add-file' ).hide();

		var allowCloseWindow = $j().preventCloseWindow( { 
			message: gM( 'mwe-prevent-close')
		} );

			
		// remove ability to change files
		// ideally also hide the "button"... but then we require styleable file input CSS trickery
		// although, we COULD do this just for files already in progress...

		// it might be interesting to just make this creational -- attach it to the dom element representing 
		// the progress bar and elapsed time	
		_this.makeTransitioner(
			'new', 
			'transporting', 
			'transported', 
			'transportProgress', 
			'transportWeight', 
			'#mwe-upwiz-progress',
			gM( 'mwe-upwiz-uploading' ),
			function( upload ) {
				upload.start();
			},
		        function() { 
				allowCloseWindow();
				$j().notify( gM( 'mwe-upwiz-files-complete' ) );
				$j( '#mwe-upwiz-stepdiv-file' ).enableNextButton();
		  	} 
		);
	},

	
	
	/**
	 * Occurs whenever we need to update the interface based on how many files there are 
	 * Thhere is an uncounted upload, waiting to be used, which has a fileInput which covers the
	 * "add an upload" button. This is absolutely positioned, so it needs to be moved if another upload was removed.
	 * The uncounted upload is also styled differently between the zero and n files cases
	 */
	updateFileCounts: function() {
		var _this = this;

		if ( _this.uploads.length ) {
			$j( '#mwe-upwiz-upload-ctrl' ).removeAttr( 'disabled' ); 
			$j( '#proceed' ).show();
			$j( '#mwe-upwiz-add-file' ).html( gM( 'mwe-upwiz-add-file-n' ) );
			$j( '#mwe-upwiz-add-file-container' ).removeClass('mwe-upwiz-add-files-0');
			$j( '#mwe-upwiz-add-file-container' ).addClass('mwe-upwiz-add-files-n');
		} else {
			$j( '#mwe-upwiz-upload-ctrl' ).attr( 'disabled', 'disabled' ); 
			$j( '#proceed' ).hide();
			$j( '#mwe-upwiz-add-file' ).html( gM( 'mwe-upwiz-add-file-0' ) );
			$j( '#mwe-upwiz-add-file-container' ).addClass('mwe-upwiz-add-files-0');
			$j( '#mwe-upwiz-add-file-container' ).removeClass('mwe-upwiz-add-files-n');
		}

		if ( _this.uploads.length < _this.maxUploads ) {
			$j( '#mwe-upwiz-add-file' ).removeAttr( 'disabled' );
			$j( _this.uploadToAdd.ui.div ).show();
			_this.uploadToAdd.ui.moveFileInputToCover( '#mwe-upwiz-add-file' );
		} else {
			$j( '#mwe-upwiz-add-file' ).attr( 'disabled', true );
			$j( _this.uploadToAdd.ui.div ).hide();
		}


	},

	/**
	 * Submit all edited details and other metadata
	 * Works just like startUploads -- parallel simultaneous submits with progress bar.
	 */
	detailsSubmit: function( endCallback ) {
		var _this = this;
		// some details blocks cannot be submitted (for instance, identical file hash)
		_this.removeBlockedDetails();

		// check that it's even possible to submit all
		
		// remove all controls
		//$j( '#mwe-upwiz-upload-ctrl' ).hide();
		//$j( '#mwe-upwiz-add-file' ).hide();
		
		// remove ability to edit details
		// maybe add some sort of greyish semi-opaque thing
		
		// add the upload progress bar, with ETA
		// add in the upload count 
		_this.makeTransitioner(
			'details', 
			'submitting-details', 
			'complete', 
			'detailsProgress', 
			'detailsWeight', 
			'#mwe-upwiz-macro-progress',
			gM( 'mwe-upwiz-editing' ),
			function( upload ) {
				upload.details.submit();
			},
			endCallback
		);
	},

	/**
	 * Removes(?) details that we can't edit for whatever reason -- might just advance them to a different state?
	 */
	removeBlockedDetails: function() {
		
	},


	prefillThanksPage: function() {
		var _this = this;
		
		$j( '#mwe-upwiz-thanks' ).append( $j( '<p>' ).append( gM( 'mwe-upwiz-thanks-intro' ) ) );
		var width = mw.getConfig( 'thumbnailWidth' );

		$j.each( _this.uploads, function(i, upload) {
			var thanksDiv = $j( '<div class="mwe-upwiz-thanks ui-helper-clearfix" />' );
			_this.thanksDiv = thanksDiv;
			
			var thumbnailDiv = $j( '<div></div>' ).addClass( 'mwe-upwiz-thumbnail' );
			thanksDiv.append( thumbnailDiv );
			upload.setThumbnail( thumbnailDiv );

			//var thumbTitle = upload.title.replace(/^File/, 'Image'); // XXX is this really necessary?
			var thumbWikiText = "[[" + upload.title + "|thumb]]";

			thanksDiv.append(
				$j( '<div class="mwe-upwiz-data"></div>' )
					.append( 
						$j('<p/>').append( 
							gM( 'mwe-upwiz-thanks-link',
								$j( '<a />' )
									.attr( { target: '_new', 
										 href: upload.imageinfo.descriptionurl } )
									.text( upload.title ) 
							) 
						), 
						$j('<p/>').append( 
							gM( 'mwe-upwiz-thanks-wikitext' ),
							$j( '<br />' ),
						 	$j( '<textarea class="mwe-long-textarea" rows="1"/>' )
								.growTextArea()
								.append( thumbWikiText ) 
								.resizeIfNeeded()
						),
						$j('<p/>').append( 
							gM( 'mwe-upwiz-thanks-url' ),
							$j( '<br />' ),
						 	$j( '<textarea class="mwe-long-textarea" rows="1"/>' )
								.growTextArea()
								.append( upload.imageinfo.descriptionurl ) 
								.resizeIfNeeded()
						)
					)
			);

			$j( '#mwe-upwiz-thanks' ).append( thanksDiv );
		} ); 
	},

	/**
	 *
	 */
	pause: function() {

	},

	/**
	 *
	 */
	stop: function() {

	}
};


mw.UploadWizardDeedPreview = function(upload) {
	this.upload = upload;
};

mw.UploadWizardDeedPreview.prototype = {
	setup: function() {
		var _this = this;
		// add a preview on the deeds page
		var thumbnailDiv = $j( '<div></div>' ).addClass( 'mwe-upwiz-thumbnail' );
		$j( '#mwe-upwiz-deeds-thumbnails' ).append( thumbnailDiv );
		_this.upload.setThumbnail( thumbnailDiv, mw.getConfig( 'smallThumbnailWidth' ), 'mwe-upwiz-smallthumbnail' );
	}
};

mw.UploadWizardNullDeed = $j.extend( new mw.UploadWizardDeed(), {
	isReady: function() { return false; },

	setQuantity: function( n ) { return; }
	
} );





/**
 * @param selector where to put this deed chooser
 * @param isPlural whether this chooser applies to multiple files (changes messaging mostly)
 */ 
mw.UploadWizardDeedChooser = function( selector ) {
	var _this = this;
	_this.selector = selector;
	_this.deed = mw.UploadWizardNullDeed;

	items = [];
	$j.each( [ 'ownwork', 'thirdparty' ], function (i, key) {
		var item = 
			'<div class="mwe-upwiz-macro-deed-' + key + ' mwe-upwiz-deed">'
		       +   '<div class="mwe-upwiz-deed-option-title">'
		       +     '<span class="mwe-upwiz-deed-header mwe-closed">'
		       +        '<a class="mwe-upwiz-deed-header-link mwe-upwiz-deed-name"></a>'
		       +     '</span>'
		       +     '<span class="mwe-upwiz-deed-header mwe-open" style="display: none;">' 
		       +       '<span class="mwe-upwiz-deed-name"></span>'
		       +       ' <a class="mwe-upwiz-macro-deeds-return">' + gM( 'mwe-upwiz-change' ) + '</a>'
		       +     '</span>'
		       +   '</div>'
		       +   '<div class="mwe-upwiz-deed-form"></div>'		
		       + '</div>'
		items.push(item);
	} );

	$j( selector ).html( items.join('') );

	$j( '.mwe-upwiz-macro-deeds-return' ).click( function() { 
		_this.choose( mw.UploadWizardNullDeed );
		_this.showDeedChoice(); 
	} );

	_this.choose( mw.UploadWizardNullDeed );
	_this.showDeedChoice();		
	
	// set up the deed interfaces
	_this.deeds = {
		'ownwork' : _this.setupDeedOwnWork(),
		'thirdparty' : _this.setupDeedThirdParty()
	};

	_this.setQuantity();
};


mw.UploadWizardDeedChooser.prototype = {

	count: 0,

	attach: function( upload ) {
		var _this = this;
		upload.deedChooser = _this;
		_this.count++;
		_this.setQuantity();	
	},

	detach: function( upload ) {
		_this.count--;
		_this.setQuantity();	
	},

	// modify various interface strings depending on singular, multiple deeds
	setQuantity: function() {
		var _this = this;
		mw.log( "setting quantity of deed to " + _this.count );
		var isPlural = _this.count > 1;
		$j.each( [ 'ownwork', 'thirdparty' ], function (i, key) {
			
			// fix the deed title that opens and closes
			gMkey = isPlural ? key + '-plural' : key;
			$j( _this.selector )
				.find( '.mwe-upwiz-macro-deed-' + key)
				.find( '.mwe-upwiz-deed-name' )
				.html( gM( 'mwe-upwiz-source-' + gMkey ) );

			// any other internal strings in the deed
			if ( _this.deeds[key] ) {
				_this.deeds[key].setQuantity( _this.count );
			}
			
		} );
		$j( _this ).trigger( 'setQuantityEvent' );

	},

	choose: function( deed ) {
		var _this = this;
		_this.deed = deed;
		if ( deed === mw.UploadWizardNullDeed ) {
			$j( _this ).trigger( 'chooseNullDeed' );
			//_this.trigger( 'isNotReady' );
			$j( _this.selector )
				.find( 'input.mwe-accept-deed' )
				.attr( 'checked', false )
		} else {
			$j( _this ).trigger( 'chooseDeed' );
		}
	},

	/**
	 * Go back to original source choice. 
	 * Assumed that we are in details mode.
	 */
	showDeedChoice: function() {
		var _this = this;
		$j( _this.selector ).find( '.mwe-upwiz-deed-header.mwe-open' ).hide();
		$j( _this.selector ).find( '.mwe-upwiz-deed-header.mwe-closed' ).show();
		$j( _this.selector ).find( '.mwe-upwiz-deed' ).maskSafeShow();
		$j( _this.selector ).find( '.mwe-upwiz-deed-form' ).maskSafeHide();
	}, 

	/**
	 * From the deed choice page, show a particular deed
	 */
	showDeed: function( deedSelector ) {
		$j( deedSelector ).find( '.mwe-upwiz-deed-header.mwe-open' ).show();
		$j( deedSelector ).find( '.mwe-upwiz-deed-header.mwe-closed' ).hide();
		$j( deedSelector ).siblings().maskSafeHide();
		$j( deedSelector ).find( '.mwe-upwiz-deed-form' ).maskSafeShow();
	},
	
	/**
	 * Set up the form and deed object for the deed option that says these uploads are all the user's own work.
	 */
	setupDeedOwnWork: function() {
		mw.log("setupdeed own work");	
		var _this = this;

		var authorInput = $j( '<input />')
			.attr( { name: "author" } )
			.addClass( 'mwe-upwiz-sign' );

		var licenseInputDiv = $j( '<div class="mwe-upwiz-deed-license"></div>' );
		var licenseInput = new mw.UploadWizardLicenseInput( licenseInputDiv );
		licenseInput.setDefaultValues();

		var ownWorkDeed = $j.extend( new mw.UploadWizardDeed(), {

			licenseInput: licenseInput,

			isReady: function() {
				return ( 
					( $j( _this.selector ).find( '.mwe-accept-deed' ).is( ':checked' ) !== 0 )
						&&
					licenseInput.isSet()
				);
			},

			getSourceWikiText: function() {
				return '{{own}}';
			},

			getAuthorWikiText: function() {
				return "[[User:" + mw.getConfig('userName') + '|' + $j( authorInput ).val() + ']]';
			},


			getLicenseWikiText: function() {
				var wikiText = '{{self';
				$j.each ( licenseInput.getTemplates(), function( i, template ) {
					wikiText += '|' + template;
				} );
				wikiText += '}}';
				return wikiText;
			},

			createInterface: function( deedChooser ) {
				var _this = this;
				_this.deedChooser = deedChooser;

				var standardDiv = $j( '<div />' )
					.append( 
						$j( '<input />') 
							.attr( { type: 'checkbox' } )
							.click( function() {
								if ( $j( this ).is( ':checked' ) ) {
									$j( deedChooser.selector )
										.find( '.mwe-upwiz-deed-accept-ownwork-custom' )
										.attr( 'checked', false );
									_this.licenseInput.setDefaultValues();
									deedChooser.choose( ownWorkDeed );
								} else {
									deedChooser.choose( mw.UploadWizardNullDeed );
								}
							} )
							.addClass( 'mwe-upwiz-deed-accept-ownwork-default mwe-accept-deed mwe-checkbox-hang-indent' ),

						// text added in setQuantit
						$j( '<p class="mwe-upwiz-source-ownwork-assert mwe-checkbox-hang-indent-text"/>' ),

						$j( '<p />' )
							.addClass( 'mwe-checkbox-hang-indent-text' )
							.addClass( 'mwe-small-print' )
							.html( gM ( 'mwe-upwiz-source-ownwork-assert-note' ) )
					);

				var toggleDiv = $j('<div />');

				var customDiv = $j('<div/>')
					.maskSafeHide()
					.append( 
						$j( '<input />') 
							.attr( { type: 'checkbox' } )
							.click( function() { 
								if ( $j( this ).is( ':checked' ) ) {
									$j( deedChooser.selector )
										.find( '.mwe-upwiz-deed-accept-ownwork-default' )
										.attr( 'checked', false )
									deedChooser.choose( ownWorkDeed ); 
								} else {
									deedChooser.choose( mw.UploadWizardNullDeed );
								}
							} )
							.addClass( 'mwe-upwiz-deed-accept-ownwork-custom mwe-accept-deed mwe-checkbox-hang-indent' ),
						$j( '<p class="mwe-upwiz-source-ownwork-assert-custom mwe-checkbox-hang-indent-text" />' ),
						licenseInputDiv 
					);

				$j( deedChooser.selector ).find( '.mwe-upwiz-macro-deed-ownwork .mwe-upwiz-deed-form' )
					.append( $j( '<div class="mwe-upwiz-deed-form-internal" />' )
						.append( standardDiv,
							 toggleDiv, 
							 customDiv )
					);

				
				
				mw.UploadWizardUtil.makeFadingToggler( standardDiv, toggleDiv, customDiv );

				// if they select 'fewer options', and they have selected the deed in there, we should unselect it
				$j( toggleDiv ).bind( 'close', function(e) {
					e.stopPropagation();
					if ( $j( deedChooser.selector ).find( '.mwe-upwiz-deed-accept-ownwork-custom' ).is( ':checked' ) ) {
						$j( deedChooser.selector )
							.find( '.mwe-upwiz-deed-accept-ownwork-custom' )
							.attr( 'checked', false );
						deedChooser.choose( mw.UploadWizardNullDeed );
					}
				} );

				_this.setQuantity( 1 );
			},


			setQuantity: function( n ) {
				var _this = this;
				var plural = n > 1 ? '-plural' : '';
				$j( _this.deedChooser.selector )
					.find( 'p.mwe-upwiz-source-ownwork-assert' )
					.html( gM( 'mwe-upwiz-source-ownwork-assert' + plural, 
						$j( '<input />' )
							.attr( { name: 'author' } )
							.addClass( 'mwe-upwiz-sign' ) ) );
				
				$j( _this.deedChooser.selector )
					.find( 'p.mwe-upwiz-source-ownwork-assert-custom' )
					.html( gM( 'mwe-upwiz-source-ownwork-assert-custom' + plural, 
						'<span class="mwe-custom-author-input"></span>' ) );

				// have to add the author input this way -- gM() will flatten it to a string and we'll lose it as a dom object
				$j( _this.deedChooser.selector ).find( '.mwe-custom-author-input' ).append( authorInput );

				// synchronize both username signatures
				// set initial value to configured username
				// if one changes all the others change
				$j( _this.deedChooser.selector ).find( '.mwe-upwiz-sign' )
					.attr( { value: mw.getConfig( 'userName' ) } )
					.keyup( function() { 
						var thisInput = this;
						var thisVal = $j( thisInput ).val();
						$j.each( $j( '.mwe-upwiz-sign' ), function( i, input ) {
							if (thisInput !== input) {
								$j( input ).val( thisVal );
							}
						} );
					} );
				

			}
		} ); 

		ownWorkDeed.createInterface( _this );

		$j( _this.selector ).find( '.mwe-upwiz-macro-deed-ownwork .mwe-upwiz-deed-header-link').click( 
			function() { 
				_this.showDeed( $j( _this.selector ).find( '.mwe-upwiz-macro-deed-ownwork' ) );
			}
		);

		return ownWorkDeed;
	
	},

	setupDeedThirdParty: function() {
		var _this = this;
	 	var sourceInput = $j('<textarea class="mwe-source mwe-long-textarea" name="source" rows="1" cols="40"></textarea>' )
					.growTextArea()
		var authorInput = $j('<textarea class="mwe-author mwe-long-textarea" name="author" rows="1" cols="40"></textarea>' )
					.growTextArea()
		licenseInputDiv = $j( '<div class="mwe-upwiz-deed-license"></div>' );
		licenseInput = new mw.UploadWizardLicenseInput( licenseInputDiv );
		licenseInput.setDefaultValues();

		var thirdPartyDeed = $j.extend( new mw.UploadWizardDeed(), {
			sourceInput: sourceInput,
			authorInput: authorInput,
			licenseInput: licenseInput,

			isReady: function() {
				return     (! mw.isEmpty( $j( this.sourceInput  ).val() ) ) 
					&& (! mw.isEmpty( $j( this.authorInput  ).val() ) )
					&& this.licenseInput.isSet()
			},

			createInterface: function( deedChooser ) {
				var _this = this;
				_this.deedChooser = deedChooser;

				$j( deedChooser.selector ).find( '.mwe-upwiz-macro-deed-thirdparty .mwe-upwiz-deed-form' ).append( 
					$j( '<div class="mwe-upwiz-deed-form-internal"/>' )
						.append( 
							$j( '<div class="mwe-upwiz-source-thirdparty-custom-plural-intro" />' ), 
							$j( '<div />' )
								.addClass( "mwe-upwiz-thirdparty-fields" )
								.append( $j( '<label />' )
										.attr( { 'for' : 'source' } )
										.text( gM( 'mwe-upwiz-source' ) ) )
								.append( sourceInput ),
							$j( '<div />' )
								.addClass( "mwe-upwiz-thirdparty-fields" )
								.append( $j( '<label />' )
										.attr( { 'for' : 'author' } )
										.text( gM( 'mwe-upwiz-author' ) ) )
								.append( authorInput ),
							$j( '<div />' ).addClass( 'mwe-upwiz-thirdparty-license' )
								       .text( gM( 'mwe-upwiz-source-thirdparty-license' ) ),
							licenseInputDiv
						)
				);
		
				thirdPartyDeed.setQuantity( 1 );	
			},


			setQuantity: function( n ) {
				var _this = this;
				$j( _this.deedChooser.selector )
					.find( 'div.mwe-upwiz-source-thirdparty-custom-plural-intro' )
 					.html( n > 1 ? gM( 'mwe-upwiz-source-thirdparty-custom-plural-intro' ) : '' );
			}

				
		} );
	
		thirdPartyDeed.createInterface( _this );
		
		// set up the header	
		$j( _this.selector ).find( '.mwe-upwiz-macro-deed-thirdparty .mwe-upwiz-deed-header-link').click( 
			function() { 
				_this.showDeed( $j( _this.selector ).find( '.mwe-upwiz-macro-deed-thirdparty' ) );
				_this.choose( thirdPartyDeed );
			}
		);	

		return thirdPartyDeed;
	}
};



/**
 * Miscellaneous utilities
 */
mw.UploadWizardUtil = {

	/**
	 * make a "more" options toggle which makes the standard div fade when 'more' is open
	 * @param standardDiv the div representing the standard options
	 * @param toggleDiv the div which has the control to open and shut custom options
	 * @param customDiv the div containing the custom options
	 */
	makeFadingToggler: function( standardDiv, toggleDiv, moreDiv ) {
		return mw.UploadWizardUtil._makeToggler( standardDiv, toggleDiv, moreDiv, true );
	},


	/**
  	 * make a standard toggler that just opens up a new panel
	 * @param toggle div -- where to put the 'more/fewer options' button
	 * @param moreDiv -- the div to hide or show
	 */
	makeMoreToggler: function( toggleDiv, moreDiv ) {
		return mw.UploadWizardUtil._makeToggler( null, toggleDiv, moreDiv, false );
	},


	/**
	 * There is a common pattern of having standard options, and then a "more options" panel which 
	 * disables the standard options panel. 
	 *
	 * We do not do anything to disable the inputs on either panel. So far, we've implemented these 
	 * in a way that the 'custom' panel is always controlling everything, but the standard panel just
	 * enters values into the custom one behind the scenes.
	 *
	 * @param standardDiv the div representing the standard options
	 * @param toggleDiv the div which has the control to open and shut custom options
	 * @param moreDiv the div containing the custom options
	 * @param fade whether to fade standardDiv when moreDiv is open
	 */
	_makeToggler: function ( standardDiv, toggleDiv, moreDiv, fade ) {
		if (fade === undefined) { 
			fade = false;
		}

		var icon = $j( '<div class="ui-icon ui-icon-triangle-1-e" style="display: inline-block; margin-top: 3px;">' );
		var text = $j( '<span>' ).append( gM( 'mwe-upwiz-more-options' ) ); 
		var toggle = function() { 
			var open = ! ( $j( this ).data( 'open' ) ) ;
			$j( this ).data( 'open', open );
			// on toggle:
			if ( open ) {
				// set out class to show the "close" message
				text.text( gM( 'mwe-upwiz-fewer-options' ) );
				icon.removeClass( "ui-icon-triangle-1-e" )
				    .addClass( "ui-icon-triangle-1-s" );
				moreDiv.maskSafeShow();
				if (fade) { 
					standardDiv.mask();
				}
			} else {
				text.text( gM( 'mwe-upwiz-more-options' ) );
				icon.removeClass( "ui-icon-triangle-1-s" )
				    .addClass( "ui-icon-triangle-1-e" )
				moreDiv.maskSafeHide();
				if (fade) {
					standardDiv.unmask();
				}
				$j( this ).trigger( 'close' );
			}
		};

		$j( toggleDiv )
			.addClass( 'mwe-more-options' )
			.append( $j( '<a />' )
				.click( toggle )
				.data( 'open', false )
				.append( icon, text ) );
	
	},

	/**
	 * remove an item from an array. Tests for === identity to remove the item
	 *  XXX the entire rationale for this file may be wrong. 
	 *  XXX The jQuery way would be to query the DOM for objects, not to keep a separate array hanging around
	 * @param items  the array where we want to remove an item
	 * @param item	 the item to remove
	 */
	removeItem: function( items, item ) {
		for ( var i = 0; i < items.length; i++ ) {
			if ( items[i] === item ) {
				items.splice( i, 1 );
				break;
			}
		}
	},

	/** 
	 * Capitalise first letter and replace spaces by underscores
	 * @param filename (basename, without directories)
	 * @return typical title as would appear on MediaWiki
	 */
	pathToTitle: function ( filename ) {
		return mw.ucfirst( filename.replace(/ /g, '_' ) );
	},

	/** 
	 * Capitalise first letter and replace underscores by spaces
	 * @param title typical title as would appear on MediaWiki
	 * @return plausible local filename, with spaces changed to underscores.
	 */
	titleToPath: function ( title ) {
		return mw.ucfirst( title.replace(/_/g, ' ' ) );
	},

	/** 
 	 * Slice extension off a path
	 * We assume that extensions are 1-4 characters in length
	 * @param path to file, like "foo/bar/baz.jpg"
	 * @return extension, like ".jpg" or undefined if it doesn't look lke an extension.
	 */
	getExtension: function( path ) {
		var extension = undefined;
		var idx = path.lastIndexOf( '.' );
		if (idx > 0 && ( idx > ( path.length - 5 ) ) && ( idx < ( path.length - 1 ) )  ) {
			extension = path.substr( idx + 1 ).toLowerCase();
		}
		return extension;
	},

	/**
	 * Last resort to guess a proper extension
	 */
	mimetypeToExtension: {
		'image/jpeg': 'jpg',
		'image/gif': 'gif'
		// fill as needed
	}


};

/**
 * Upper-case the first letter of a string. XXX move to common library
 * @param string
 * @return string with first letter uppercased.
 */
mw.ucfirst = function( s ) {
	return s.substring(0,1).toUpperCase() + s.substr(1);
};


/**
 * jQuery extension. Makes a textarea automatically grow if you enter overflow
 * (This feature was in the old Commons interface with a confusing arrow icon; it's nicer to make it automatic.)
 */
jQuery.fn.growTextArea = function( options ) {

	// this is a jquery-style object

	// in MSIE, this makes it possible to know what scrollheight is 
	// Technically this means text could now dangle over the edge, 
	// but it shouldn't because it will always grow to accomodate very quickly.

	if ($j.msie) {
		this.each( function(i, textArea) {
			textArea.style.overflow = 'visible';
		} );
	}

	this.resizeIfNeeded = function() {
		// this is the dom element
		while (this.scrollHeight > this.offsetHeight) {
			this.rows++;
		}
		return this;
	};

	this.change(this.resizeIfNeeded);
	this.keyup(this.resizeIfNeeded);

	return this;
};

jQuery.fn.mask = function( options ) {

	// intercept clicks... 
	// Note: the size of the div must be obtainable. Hence, this cannot be a div without layout (e.g. display:none).
	// some of this is borrowed from http://code.google.com/p/jquery-loadmask/ , but simplified
	$j.each( this, function( i, el ) {
		
		if ( ! $j( el ).data( 'mask' ) ) {
			

			//fix for z-index bug with selects in IE6
			if ( $j.browser.msie && $j.browser.version.substring(0,1) === '6' ){
				el.find( "select" ).addClass( "masked-hidden" );
			}

			var mask = $j( '<div />' )
					.css( { 'position' : 'absolute',
						'top'      : '0px', 
						'left'     : '0px',
						'width'	   : el.offsetWidth + 'px',
						'height'   : el.offsetHeight + 'px',
						'z-index'  : 100 } )
					.click( function( e ) { e.stopPropagation(); } );

			$j( el ).css( { 'position' : 'relative' } )	
				.fadeTo( 'fast', 0.5 )
				.append( mask )
				.data( 'mask', mask );

			//auto height fix for IE -- not sure about this, i think offsetWidth + Height is a better solution. Test!
			/*
			if( $j.browser.msie ) {
				mask.height(el.height() + parseInt(el.css("padding-top")) + parseInt(el.css("padding-bottom")));
				mask.width(el.width() + parseInt(el.css("padding-left")) + parseInt(el.css("padding-right")));
			}
			*/

		} 

		// XXX bind to a custom event in case the div size changes : ?

	} );

	return this;

};

jQuery.fn.unmask = function( options ) {

	$j.each( this, function( i, el ) {
		if ( $j( el ).data( 'mask' ) ) {
			var mask = $j( el ).data( 'mask' );
			$j( el ).removeData( 'mask' ); // from the data
			mask.remove(); // from the DOM
			$j( el ).fadeTo( 'fast', 1.0 );
		}
	} );

	
	return this;
};


/** 
 * Safe hide and show
 * Rather than use display: none, this collapses the divs to zero height
 * This is good because then the elements in the divs still have layout and we can do things like mask and unmask (above)
 * XXX may be obsolete as we are not really doing this any more
 */ 

jQuery.fn.maskSafeHide = function( options ) {
	return this.css( { 'height' : '0px', 'overflow' : 'hidden' } );
};

// XXX check overflow properties, is auto/auto not the right thing?
// may be causing scrollbar to appear when div changes size
jQuery.fn.maskSafeShow = function( options ) {
	return this.css( { 'height' : 'auto', 'overflow' : 'visible' } );
};


( function( $j ) {

	/**
	 * Prevent the closing of a window with a confirm message (the onbeforeunload event seems to 
	 * work in most browsers 
	 * e.g.
	 *       var allowCloseWindow = jQuery().preventCloseWindow( { message: "Don't go away!" } );
	 *       // ... do stuff that can't be interrupted ...
	 *       allowCloseWindow();
	 *
	 * @param options 	object which should have a message string, already internationalized
	 * @return closure	execute this when you want to allow the user to close the window
	 */
	$j.fn.preventCloseWindow = function( options ) {
		if ( typeof options === 'undefined' ) {
			options = {};
		}

		if ( typeof options.message === 'undefined' ) {
			options.message = 'Are you sure you want to close this window?';
		}
		
		$j( window ).unload( function() { 
			return options.message;
		} );
		
		return function() { 
			$j( window ).removeAttr( 'unload' );
		};
				
	};


	$j.fn.notify = function ( message ) {
		// could do something here with Chrome's in-browser growl-like notifications.
		// play a sound?
		// if the current tab does not have focus, use an alert?
		// alert( message );
	};

	$j.fn.enableNextButton = function() {
		this.find( '.mwe-upwiz-button-next' )
			.removeAttr( 'disabled' );
		//	.effect( 'pulsate', { times: 3 }, 1000 );
	};

	$j.fn.disableNextButton = function() {
		this.find( '.mwe-upwiz-button-next' )
			.attr( 'disabled', true );
	}
	

} )( jQuery );
